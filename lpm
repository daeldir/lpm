#!/usr/bin/python2
# -*- encoding: utf-8 -*-

# Initialisation
import sys, codecs
from os import getcwd, path

sys.stdout = codecs.getwriter("utf-8")(sys.stdout) 

DEFAULT_LENGTH = 80

# Fonctions utiles
def detect_starline(line):
    if len(line) < 2:
        return False
    for c in line:
        if c != "*":
            return False
    return True

def begin(line, begin):
    if len(line) < len(begin):
        return False
    return line[:len(begin)].lower() == begin

def debugDisplay(kind, deep, line = ""):
    indent = ""
    for i in range(deep):
        indent += "'"
    l = "-%s-%s%s" % (kind.ljust(10), indent, line)
    print l[:min(len(l),75)]

def escape(txt):
    r = u""
    for i in range(len(txt)):
        if i == 0:
            if txt[i] in ["-", "#", "'", "="]:
                r += "\\"
        elif i < len(txt)-2:
            if txt[i:i+2] in ["--", "__", "//", "**"]:
                r += "\\"
        elif txt[i] in ["\\", "*", "<", ">", "[", "]", "~"]:
            r += "\\"
        r += txt[i]
    return r

def addSpaceAfter(line, c, direction):
    l = len(line)
    if direction == 1:
        start = 4
        stop = l-4
    else:
        start = l-5
        stop = 3
    for i in range(start, stop, direction):
        if line[i:i+3] != c+"  " and line[i:i+2] == c+" ":
            return True, line[:i+1]+" "+line[i+1:]
    return False, line
def addSpaceBefore(line, c, direction):
    l = len(line)
    if direction == 1:
        start = 4
        stop = l-4
    else:
        start = l-5
        stop = 3
    for i in range(start, stop, direction):
        if line[i-2:i+1] != "  "+c and line[i-1:i+1] == " "+c:
            return True, line[:i-1]+" "+line[i-1:]
    return False, line

def addSpaceAnywhere(line, direction):
    l = len(line)
    if direction == 1:
        start = 4
        stop = l-4
    else:
        start = l-5
        stop = 3
    spaces = []
    last = ""
    for i in range(start, stop, direction):
        if line[i] == " ":
            if last == " ":
                spaces[-1]["c"] += 1
            else:
                spaces.append({"i":i, "c": 1})
        last = line[i]
    if len(spaces) == 0:
        return False, line
    least = spaces[0]
    for i in spaces:
        if i["c"] < least["c"]:
            least = i
    most = []
    for i in spaces:
        if i["c"] == least["c"]:
            most.append(i)
    c = most[int(len(most)/2)]["i"]
    return True, line[:c]+" "+line[c:]

def addSpace(line, direction):
    r, line = addSpaceAfter(line, ".", direction)
    if not r:
        r, line = addSpaceAfter(line, ",", direction)
    if not r:
        r, line = addSpaceAfter(line, ")", direction)
    if not r:
        r, line = addSpaceAfter(line, "]", direction)
    if not r:
        r, line = addSpaceAfter(line, ">", direction)
    if not r:
        r, line = addSpaceBefore(line, "-", direction)
    if not r:
        r, line = addSpaceBefore(line, "-", direction)
    if not r:
        r, line = addSpaceBefore(line, "(", direction)
    if not r:
        r, line = addSpaceBefore(line, "[", direction)
    if not r:
        r, line = addSpaceBefore(line, "<", direction)
    if not r:
        r, line = addSpaceAnywhere(line, direction)
    return line

def justify(line, length):
    l = len(line)
    direction = 1
    while len(line) < length:
        line = addSpace(line, direction).strip()
        direction *= -1
    return line

# Importation
class Code:
    def __init__(self, line):
        """ Contient un morceau de code """
        self.type = "code"
        self.language = None
        self.raw_code = []
        self.code = []

        split = line.split(":")
        language = split[0]
        if "(" in language:
            language = language.split("(")[1]
            if ")" in language:   
                self.language = language.split(")")[0]
        name = ":".join(split[1:])
        if name.strip() != "":
            self.name = name.strip()
        else:
            self.name = None

    def append(self, line):
        self.raw_code.append(line)

    def important(self):
        """ Renvoie False si le morceau de code est vide et n'a pas de nom. """
        if self.name != None:
            return True
        for i in self.raw_code:
            # Le strip nous empêche d'écrire des codes anonymes en whitespace.
            # Tant pis.
            if i.strip() != "":
                return True
        return False

    def debugDisplay(self, deep):
        if self.name == None:
            name = u"None"
        else:
            name = self.name
        if self.language == None:
            language = u"None"
        else:
            language = self.language
        debugDisplay("code chunk", deep, "language: "+language+u", name: "+name)
        for i in self.code:
            i.debugDisplay(deep+1)
    def formatText(self, length):
        if self.name == None:
            name = u""
        else:
            name = self.name
        if self.language == None:
            language = u""
        else:
            language = " ("+self.language+")"
        r = u"<Code"+language+": "+name+"\n"
        for i in self.code:
            r += i.formatText(length)
        r += ">\n"
        return r
    def outputHTML(self):
        if self.name == None:
            name = u""
        else:
            name = "<span class=\"\codename\">"+self.name+"</span>"
        if self.language == None:
            language = u""
        else:
            language = "<span class=\"codelang\">("+self.language+")</span>"
        r = u"<div class=\"codechunk\">&lt;Code"+language+": "+name+"\n"
        for i in self.code:
            r += i.outputHTML()
        r += "&gt;</div>\n"
        return r
    
    def parse(self):
        for i in self.raw_code:
            if len(i.strip()) > 0 and i.strip()[0] == "<":
                self.code.append(self.Reference(i))
            else:
                self.code.append(self.Line(i))
        pass

    class Line:
        def __init__(self, line):
            """ Crée une ligne sans le retour à la ligne final. """
            if line != "" and line[-1] == "\n":
                line = line[:-1]
            if len(line) > 0 and line[0] == "\\":
                line = line[1:]
            self.line = line
        def debugDisplay(self, deep):
            debugDisplay("codeline", deep, self.line+u"'")
        def formatText(self, length):
            sline = self.line.strip()
            if sline != "" and sline[0] in ["<", ">", "\\"]:
                return "\\"+self.line+"\n"
            else:
                return self.line+"\n"
        def outputHTML(self):
            return "<div>"+self.line.replace(" ", "&nbsp;").replace("<", "&lt;")+"</div>\n"

    class Reference:
        def __init__(self, line):
            self.indentation = ""
            for c in line:
                if c != " " and c != "\t":
                    break
                self.indentation += c
            self.name = line.strip()[1:].strip()
        def debugDisplay(self, deep):
            debugDisplay("coderef", deep, u"dest: «"+self.name+u"», indent: |]"+self.indentation+u"[>")
        def formatText(self, length):
            return self.indentation+"<"+self.name+"\n"
        def outputHTML(self):
            return "<div class=\"coderef\">"+self.indentation.replace(" ", "&nbsp;")+"&lt;"+self.name.replace("<", "&lt;")+"</div>\n"

class Paragraph:
    def __init__(self):
        self.line = ""
        self.content = []
    def append(self, line):
        for i in line.split():
            self.line += u" "+i
        self.line = self.line.strip()
    def debugDisplay(self, deep):
        debugDisplay("par", deep)
        for i in self.content:
            i.debugDisplay(deep+1)
    def formatText(self, length, prefixed = False):
        r = u""
        for i in self.content:
            r += i.formatText(length)
        t = r.split()
        t2 = []
        l = u""
        for i in r.split():
            if len(l)+len(i)+1 < length:
                l += i+" "
            else:
                t2.append(l)
                l = i+" "
        t2.append(l)
        r = u""
        for i in t2[:-1]:
            r += justify(i, length)+"\n"
        r += t2[-1]+"\n"
        if not prefixed:
            r = u"\n\n"+r
        return r
    def outputHTML(self):
        r = u"<p>"
        for i in self.content:
            r += i.outputHTML()+" "
        return r+"</p>"
    def important(self):
        return len(self.line) > 0
    def parse(self):
        mode = [self.Text()]
        i = 0
        while i < len(self.line):
            c = self.line[i]
            if mode[-1].type == "escape":
                mode.pop()
                mode[-1].add(c)
            elif mode[-1].type in ["link", "anchor"]:
                if c == "]":
                    mode = self.parseChange(mode)
                else:
                    mode[-1].add(c)
            elif c == "\\":
                mode.append(self.Escape())
            elif mode[-1].type == "code":
                if c == ">":
                    mode = self.parseChange(mode)
                else:
                    mode[-1].add(c)
            elif self.line[i:i+2] == "//":
                if mode[-1].type != "italic":
                    mode.append(self.Italic())
                else:
                    mode = self.parseChange(mode)
                i += 1
            elif self.line[i:i+2] == "__":
                if mode[-1].type != "underline":
                    mode.append(self.Underline())
                else:
                    mode = self.parseChange(mode)
                i += 1
            elif self.line[i:i+2] == "--":
                if mode[-1].type != "overline":
                    mode.append(self.Overline())
                else:
                    mode = self.parseChange(mode)
                i += 1
            elif self.line[i:i+2] == "**":
                if mode[-1].type != "bold":
                    mode.append(self.Bold())
                else:
                    mode = self.parseChange(mode)
                i += 1
            elif c == "*":
                mode.append(self.NoteRef())
                mode = self.parseChange(mode)
            elif c == "[":
                if mode[-1].type == "text":
                    linktext = self.Text()
                    if i != 0 and self.line[i-1] != " ":
                        linktext.add(self.line[:i].split()[-1])
                        mode[-1].content = mode[-1].content[:-len(linktext.content)]
                else:
                    linktext = mode.pop()
                if self.line[i:i+4] == "[..]":
                    mode.append(self.URLRef())
                    mode[-1].content = linktext
                    mode = self.parseChange(mode)
                    i += 3
                elif self.line[i+1] == "=":
                    mode.append(self.Anchor())
                    mode[-1].content = linktext
                    i += 1
                else:
                    mode.append(self.Link())
                    mode[-1].content = linktext
                text = ""
            elif c == "(":
                mode.append(self.Bracket())
            elif c == ")" and mode[-1].type == "bracket":
                if self.line[i+1] != "[":
                    mode = self.parseChange(mode)
            elif c == "<":
                mode.append(self.Code())
                if self.line[i+1] == "<":
                    lang = self.line[i+2:].split(">")[0]
                    mode[-1].lang = lang
                    i += len(lang)+2
            else:
                mode[-1].add(c)
            i += 1
        self.parseChange(mode)

    def parseChange(self, mode):
        el = mode.pop()
        if len(mode) == 0:
            self.content.append(el)
            mode.append(self.Text())
        elif mode[-1].type == "text":
            el2 = mode.pop()
            if len(mode) > 0:
                mode[-1].append(el2)
                mode[-1].append(el)
            else:
                self.content.append(el2)
                self.content.append(el)
            mode.append(self.Text())
        else:
            mode[-1].append(el)
        return mode
        
    class Text:
        def __init__(self, content = u""):
            self.type = "text"
            self.content = content
        def add(self, el):
            self.content += el
        def debugDisplay(self, deep):
            debugDisplay("text", deep, self.content)
        def formatText(self, length):
            return escape(self.content)
        def outputHTML(self):
            return self.content

    class Bold:
        def __init__(self):
            self.type = "bold"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("bold", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = u""
            for i in self.content:
                r += i.formatText(length)
            return "**"+r+"**"
        def outputHTML(self):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "<span class=\"bold\">"+r+"</span>"

    class Italic:
        def __init__(self):
            self.type = "italic"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("italic", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = u""
            for i in self.content:
                r += i.formatText(length)
            return "//"+r+"//"
        def outputHTML(self):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "<span class=\"italic\">"+r+"</span>"

    class Underline:
        def __init__(self):
            self.type = "underline"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("underline", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = u""
            for i in self.content:
                r += i.formatText(length)
            return "__"+r+"__"
        def outputHTML(self):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "<span class=\"underline\">"+r+"</span>"

    class Overline:
        def __init__(self):
            self.type = "overline"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("overline", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = u""
            for i in self.content:
                r += i.formatText(length)
            return "--"+r+"--"
        def outputHTML(self):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "<span class=\"overline\">"+r+"</span>"

    class Bracket:
        def __init__(self):
            self.type = "bracket"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("bracket", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = "("
            for i in self.content:
                r += i.formatText(length)
            r += ")"
            return r
        def outputHTML(self):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "("+r+")"

    class Code:
        def __init__(self):
            self.type = "code"
            self.content = u""
            self.lang = None
        def add(self, el):
            self.content += el
        def debugDisplay(self, deep):
            if self.lang == None:
                lang = "None"
            else:
                lang = self.lang
            debugDisplay("code", deep, u"("+lang+u")"+self.content)
        def formatText(self, length):
            if self.lang == None:
                lang = ""
            else:
                lang = "<"+self.lang+">"
            return "<"+lang+escape(self.content)+">"
        def outputHTML(self):
            if self.lang == None:
                lang = ""
            else:
                lang = "<span>"+self.lang+"</span>"
            return "<span class=\"code_span\">&lt;"+self.content+"&gt;</span>"

    class URLRef:
        def __init__(self):
            self.type = "urlref"
            self.content = Paragraph.Text()
            self.ref = None
        def debugDisplay(self, deep):
            debugDisplay("urlref", deep)
            self.content.debugDisplay(deep+1)
        def formatText(self, length):
            return self.content.formatText(length)+"[..]"
        def outputHTML(self):
            if self.ref == None:
                ref = "#"
            else:
                ref = self.ref.url
            return "<a href=\""+ref+"\" target=\"about:blank\">"+self.content.outputHTML()+"</a>"

    class Link:
        def __init__(self):
            self.type = "link"
            self.name = ""
            self.content = Paragraph.Text()
        def add(self, el):
            self.name += el
        def debugDisplay(self, deep):
            debugDisplay("link", deep)
            self.content.debugDisplay(deep+1)
        def formatText(self, length):
            return self.content.formatText(length)+"["+self.name+"]"
        def outputHTML(self):
            return "<a href=\"#"+self.name+"\">"+self.content.outputHTML()+"</a>"

    class Anchor:
        def __init__(self):
            self.type = "anchor"
            self.name = ""
            self.content = Paragraph.Text()
        def add(self, el):
            self.name += el
        def debugDisplay(self, deep):
            debugDisplay("anchor", deep, "name: "+self.name)
            self.content.debugDisplay(deep+1)
        def formatText(self, length):
            return self.content.formatText(length)+"[="+self.name+"]"
        def outputHTML(self):
            return "<a name=\""+self.name+"\">"+self.content.outputHTML()+"</a>"

    class NoteRef:
        def __init__(self):
            self.type = "noteref"
            self.ref = None
        def debugDisplay(self, deep):
            debugDisplay("noteref", deep)
        def formatText(self, length):
            return "*"
        def outputHTML(self):
            if self.ref != None:
                ref = self.ref.count
            else:
                ref = "0"
            return "<a href=\"#ref"+ref+"\" name=\"toref"+ref+"\"><exp>"+ref+"</exp></a>"

    class Escape:
        def __init__(self):
            self.type = "escape"

class OrderedList:
    def __init__(self, line):
        self.content = [line]
        self.pars = []
    def append(self, line):
        self.content.append(line.strip())
    def debugDisplay(self, deep):
        debugDisplay("ol", deep)
        for i in self.pars:
            i.debugDisplay(deep+1)
    def important(self):
        return len(self.content) > 0
    def parse(self):
        for line in self.content:
            line = line.strip()
            if begin(line, "#"):
                self.pars.append(Documentation())
            if begin(line, "#") or begin(line, "'"):
                line = line[1:]
            self.pars[-1].append(line)
        for i in self.pars:
            i.parse()
    def formatText(self, length, prefixed = None):
        r = u""
        for par in self.pars:
            par = par.formatText(length-3).strip().split("\n")
            r += " # "+par[0].strip()+"\n"
            for i in par[1:]:
                r += " ' "+i.strip()+"\n"
        return r+"\n"
    def outputHTML(self):
        r = u"<ol>"
        for par in self.pars:
            r += "<li>"+par.outputHTML()+"</li>"
        return r+"</ol>\n"

class UnorderedList:
    def __init__(self, line):
        self.content = [line]
        self.pars = []
    def append(self, line):
        self.content.append(line.strip())
    def debugDisplay(self, deep):
        debugDisplay("ul", deep)
        for i in self.pars:
            i.debugDisplay(deep+1)
    def important(self):
        return len(self.content) > 0
    def parse(self):
        for line in self.content:
            line = line.strip()
            if begin(line, "-"):
                self.pars.append(Documentation())
            if begin(line, "-") or begin(line, "'"):
                line = line[1:]
            self.pars[-1].append(line)
        for i in self.pars:
            i.parse()
    def formatText(self, length, prefixed = None):
        r = u""
        for par in self.pars:
            par = par.formatText(length-3).strip().split("\n")
            r += " - "+par[0].strip()+"\n"
            for i in par[1:]:
                r += " ' "+i.strip()+"\n"
        return r+"\n"
    def outputHTML(self):
        r = u"<ul>"
        for par in self.pars:
            r += "<li>"+par.outputHTML()+"</li>"
        return r+"</ul>\n"

class FootNote:
    def __init__(self, line):
        self.content = [line]
        self.pars = Documentation()
        self.count = 0
    def append(self, line):
        self.content.append(line)
    def debugDisplay(self, deep):
        debugDisplay("footnote", deep)
        self.pars.debugDisplay(deep+1)
    def important(self):
        return len(self.content) > 0
    def parse(self):
        for i in self.content:
            if begin(i, "*:"):
                i = i[2:].strip()
            self.pars.append(i)
        self.pars.parse()
    def formatText(self, length, prefixed = None):
        pars = self.pars.formatText(length-4, True).split("\n")
        r = "*: "+pars[0]+"\n"
        for i in pars[1:]:
            r += "    "+i
        return " "+r.strip()+"\n"
    def outputHTML(self):
        r = u"<a href=\"#toref"+str(self.count)+"\" name=\"ref"+str(self.count)+"\">^</a> "
        r += self.pars.outputHTML()
        return r


class FootURL:
    def __init__(self, line):
        self.url = line[3:].strip()
    def append(self, line):
        self.url += line.strip()
    def debugDisplay(self, deep):
        debugDisplay("footurl", deep, self.url)
    def important(self):
        return len(self.url) > 0
    def parse(self):
        pass
    def formatText(self, length, prefixed = None):
        r = u"..: "
        count = 0
        for c in self.url:
            count += 1
            r += c
            if count == length-4:
                r += "\n    "
                count = 0
        return r+"\n"
    def outputHTML(self):
        return ""

class Warn:
    def __init__(self, line):
        self.content = [line]
        self.pars = Documentation()
    def append(self, line):
        self.content.append(line)
    def debugDisplay(self, deep):
        debugDisplay("important", deep)
        self.pars.debugDisplay(deep+1)
    def important(self):
        for line in self.content:
            if line[:3] == "/!\\":
                line = line[3:]
            if line.strip() != "":
                return True
        return False
    def parse(self):
        for line in self.content:
            if line[:3] == "/!\\":
                line = line[3:].strip()
            self.pars.append(line)
        self.pars.parse()
    def formatText(self, length, prefixed = None):
        lines = self.pars.formatText(length - 4).strip().split("\n")
        r = u""
        if not prefixed:
            r += u"\n"
        for i in lines:
            r += "/!\\ "+i+"\n"
        return r
    def outputHTML(self):
        r = "<div class=\"warning\">"+self.pars.outputHTML()+"</div>"
        return r

class Image:
    def __init__(self, line):
        self.name = line
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("image", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[6:].strip()
    def formatText(self, length, prefixed = None):
        return "~Image "+self.name+"\n"
    def outputHTML(self):
        return "TODO"

class Get:
    def __init__(self, line):
        self.name = line
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("get", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[4:].strip()
    def formatText(self, length, prefixed = None):
        return "~Get "+self.name+"\n"
    def outputHTML(self):
        return "TODO"

class Include:
    def __init__(self, line):
        self.name = line
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("include", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[8:].strip()
    def formatText(self, length, prefixed = None):
        return "~Include "+self.name+"\n"
    def outputHTML(self):
        return "TODO"

class TextBlock:
    def __init__(self):
        self.raw_content = []
        self.content = []
    def append(self, line):
        if line.strip() != "":
            self.raw_content.append(line.strip())
    def debugDisplay(self, deep):
        for i in self.raw_content:
            debugDisplay("block", deep, i)
    def important(self):
        return len(self.raw_content) > 0
    def parse(self):
        """ Renvoie une liste de paragraphes et d'autres éléments (liste…) """
        mode = "par"
        element = Paragraph()
        block = []
        for line in self.raw_content:
            line = line.strip()
            if begin(line, "*:"):
                mode = "footnote"
                if element.important():
                    block.append(element)
                element = FootNote(line)
            elif begin(line, "..:"):
                mode = "footurl"
                if element.important():
                    block.append(element)
                element = FootURL(line)
            elif begin(line, "'") and mode == "unordered list":
                element.append(line)
            elif begin(line, "-") and mode == "unordered list":
                element.append("")
                element.append(line)
            elif begin(line, "-") and mode != "unordered list":
                mode = "unordered list"
                if element.important():
                    block.append(element)
                element = UnorderedList(line)
            elif begin(line, "'") and mode == "ordered list":
                element.append(line)
            elif begin(line, "#") and mode == "ordered list":
                element.append("")
                element.append(line)
            elif begin(line, "#") and mode != "ordered list":
                mode = "ordered list"
                if element.important():
                    block.append(element)
                element = OrderedList(line)
            elif begin(line, "~image"):
                mode = "image"
                if element.important():
                    block.append(element)
                block.append(Image(line))
                element = Paragraph()
            elif begin(line, "~get"):
                mode = "get"
                if element.important():
                    block.append(element)
                block.append(Get(line))
                element = Paragraph()
            elif begin(line, "~include"):
                mode = "include"
                if element.important():
                    block.append(element)
                block.append(Include(line))
                element = Paragraph()
            elif begin(line, "/!\\") and mode != "warn":
                mode = "warn"
                if element.important():
                    block.append(element)
                element = Warn(line)
            elif mode in ["image", "get", "include", "ordered list", "unordered list"]:
                mode = "par"
                if element.important():
                    block.append(element)
                element = Paragraph()
                element.append(line)
            else:
                element.append(line)
        if element.important():
            block.append(element)
        for element in block:
            element.parse()
        return block

class Documentation:
    def __init__(self):
        self.lines = []
        self.pars = []
        self.blocks = []
        self.type = "documentation"

    def append(self, line):
        self.lines.append(line.strip())

    def important(self):
        """ Renvoie False si la documentation ne contient que des lignes vides """
        for i in self.lines:
            if i != "":
                return True
        return False

    def parse(self):
        block = TextBlock()
        for i in self.lines:
            if i != "":
                block.append(i)
            else:
                if block.important():
                    self.blocks.append(block)
                block = TextBlock()
        if block.important():
            self.blocks.append(block)
        for i in self.blocks:
            self.pars += i.parse()

    def debugDisplay(self, deep):
        debugDisplay("docu", deep)
        for i in self.pars:
            i.debugDisplay(deep+1)
    def formatText(self, length, prefixed = False):
        r = u""
        for i in self.pars:
            r += i.formatText(length, prefixed)
        text = u""
        old = None
        for i in r.split("\n"):
            if not (old == "" and i.strip() == ""):
                text += i+"\n"
            old = i.strip()
        return text
    def outputHTML(self):
        r = u""
        for i in self.pars:
            r += i.outputHTML()
        return r


class Title:
    def __init__(self):
        self.name = []
    def important(self):
        """ Renvoie True si le titre n'est pas vide. """
        for i in self.name:
            if i != "":
                return True
        return False
    def append(self, c):
        self.name.append(c.strip())
    def debugDisplay(self, deep):
        for i in self.name:
            debugDisplay("title", deep, i)
    def formatText(self, line_length):
        max_width = 0
        for i in self.name:
            max_width = max(max_width, len(i))
        max_width += 2
        bar = ""
        for i in range(max_width+2):
            bar += "*"
        r = u""
        r += bar.center(line_length)+"\n"
        for i in self.name:
            text = u"*"+i.center(max_width)+u"*"
            r += text.center(line_length)+"\n"
        r += bar.center(line_length)+"\n"
        return r
    def outputHTMLTitle(self):
        r = u"<title> | "
        for i in self.name:
            r += i+u" | "
        r += "</title>\n"
        return r
    def outputHTML(self):
        r = u"<div class=\"title\">\n"
        for i in self.name:
            r += "\t<div>"+i+"</div>\n"
        r += "</div>\n"
        return r

class Introduction:
    def __init__(self):
        self.raw_content = []
        self.content = []
    def append(self, line):
        self.raw_content.append(line)
    def important(self):
        for i in self.content:
            if i != "":
                return True
        return False
    def split(self):
        last_chunk = Documentation()
        mode = "documentation"
        for line in self.raw_content:
            sline = line.strip()
            if begin(line, "<code"):
                mode = "begincode"
                if last_chunk.important():
                    self.content.append(last_chunk)
                last_chunk = Code(line)
            elif mode in ["code", "begincode"]:
                if line.rstrip() == ">":
                    mode = "endcode"
                else:
                    mode = "code"
                    last_chunk.append(line)
            elif mode == "endcode":
                mode = "documentation"
                if last_chunk.important():
                    self.content.append(last_chunk)
                last_chunk = Documentation()
            else:
                last_chunk.append(line.strip())
        if last_chunk.important():
            self.content.append(last_chunk)
    def debugDisplay(self, deep):
        debugDisplay("intro", deep)
        for i in self.content:
            i.debugDisplay(deep+1)
    def parse(self):
        for i in self.content:
            i.parse()
    def formatText(self, length):
        r = u""
        for i in self.content:
            r += i.formatText(length)
        return r
    def outputHTML(self):
        r = u""
        for i in self.content:
            r += i.outputHTML()
        return r

class Authors:
    def __init__(self):
        self.names = []
    def important(self):
        return len(self.names) > 0
    def debugDisplay(self, deep):
        for i in self.names:
            debugDisplay("authors", deep, i)
    def append(self, name):
        if name.strip() != "":
            self.names.append(name)
    def formatText(self, length):
        r = u""
        for i in self.names:
            r += u"~Authors "+i+u"\n"
        return r
    def outputHTML(self):
        r = "<div class=\"authors\">Par "
        for i in self.names:
            r += "<span>"+i+"</span>"
        return r+"</div>"


class Document:
    def __init__(self, name = None):
        """ Crée un document et charge le fichier si passé en paramètre. """
        self.type = "section"
        self.parent = None
        self.name = name
        self.position = 0
        self.sections = []
        self.introduction = Introduction()
        self.title = Title()
        self.authors = Authors()
        self.abstract = None
        self.code_type = None
        self.lines = []

    def fromFile(self, filename):
        """ Récupère le code source d'un fichier (interprète ~Get) """
        self.type = "document"
        filename = path.abspath(filename)
        basedir = path.dirname(filename)
        f = codecs.open(filename, 'r', encoding="utf-8")
        lines = f.readlines()
        f.close()
        for i in lines:
            if begin(i, "~get"):
                filename = i.strip()[4:].strip()
                if filename != "":
                    document = Document()
                    document.fromFile(path.join(basedir, filename))
                    self.lines += document.lines
            else:
                self.lines.append(i)

    def fromOneFile(self, filename):
        """ Récupère le code source d'un fichier (sans interpreter ~Get) """
        filename = path.abspath(filename)
        basedir = path.dirname(filename)
        f = codecs.open(filename, 'r', encoding="utf-8")
        lines = f.readlines()
        f.close()
        for i in lines:
            self.lines.append(i)

    def parseStructure(self, level = 0):
        """ Place les lignes dans la structure du document. """
        mode = "intro"
        introduction = True
        abstract = []
        document = Document()
        document.parent = self
        position = 1
        for line in self.lines:
            sline = line.strip()
            if begin(line, "<code"):
                mode = "begincode"
            elif mode in ["code", "begincode"]:
                if line.rstrip() == ">":
                    mode = "endcode"
                else:
                    mode = "code"
            elif begin(sline, "==") and not introduction:
                mode = "sectionpar"
                line = sline[1:]
            elif begin(sline, "="):
                mode = "section"
                line = sline.lstrip("=").strip()
                if not introduction:
                    document.parseStructure(level+1)
                introduction = False
                if document.important():
                    self.sections.append(document)
                    position = document.position+1
                document = Document(line)
                document.parent = self
                document.position = position
            elif introduction:
                if detect_starline(sline):
                    if mode in ["title", "begintitle"]:
                        mode = "endtitle"
                    else:
                        mode = "begintitle"
                elif mode in ["begintitle", "title"]:
                    mode = "title"
                    if len(sline) > 0 and sline[0] == "*":
                        sline = sline[1:]
                    if len(sline) > 2 and sline[-1] == "*":
                        sline = sline[:-1]
                    line = sline.strip()
                    self.title.append(line)
                elif begin(sline, "~authors"):
                    mode = "authors"
                    line = sline[8:].strip()
                    self.authors.append(line)
                elif begin(sline, "~code"):
                    mode = "code type"
                    line = sline[5:].strip()
                    self.code_type = line
                elif sline.lower() == "~abstract~":
                    mode = "beginabstract"
                    self.abstract = Document()
                    self.abstract.type = abstract
                elif mode in ["beginabstract", "abstract"]:
                    mode = "abstract"
                    if sline == "~~~":
                        mode = "endabstract"
                        self.abstract.parseStructure(level+1)
                    else:
                        self.abstract.lines.append(line)
            else:
                mode = "sectionpar"
            if mode in ["intro", "sectionpar", "begincode", "coderef", "endcode", "code"]:
                if introduction:
                    self.introduction.append(line)
                else:
                    document.lines.append(line)
        if not introduction:
            document.parseStructure(level+1)
        if document.important():
            self.sections.append(document)

    def getPosition(self):
        """ Renvoie un tableau contenant le chemin d'accès à cette partie du
        document, en terme de sections. """
        position = [self.position]
        parent = self.parent
        while parent != None:
            position = [parent.position]+position
            parent = parent.parent
        return position

    def debugDisplay(self, deep = 0):
        """ Affiche la structure du document """
        debugDisplay("document", deep)
        if self.title.important():
            self.title.debugDisplay(deep)
        if self.name != None:
            t = ""
            position = []
            for i in self.getPosition()[1:]:
                position.append(str(i))
            debugDisplay("secname", deep, ".".join(position)+" "+self.name)
        if self.authors.important():
            self.authors.debugDisplay(deep)
        if self.code_type != None:
            debugDisplay("set code", deep, self.code_type)
        if self.abstract != None:
            self.abstract.debugDisplay(deep)
        if self.introduction.important():
            self.introduction.debugDisplay(deep)
        for section in self.sections:
            section.debugDisplay(deep+1)

    def splitDocCode(self):
        """ Place le code et la documentation de l'introduction dans une suite
        de morceaux séparés (un morceau de code, un morceau de doc, et ainsi de
        suite), et effectue la même séparation sur les sections qui la suivent.
        """
        self.introduction.split()
        if self.abstract != None:
            self.abstract.splitDocCode()
        for section in self.sections:
            section.splitDocCode()
    def parseChunks(self):
        """ Découpe les paragraphes et prépare leur mise en forme. """
        self.introduction.parse()
        if self.abstract != None:
            self.abstract.parseChunks()
        for section in self.sections:
            section.parseChunks()
    def important(self):
        if self.name != "" and self.name != None:
            return True
        for i in self.sections:
            if i.important:
                return True
        if self.introduction.important():
            return True
        if self.title.important():
            return True
        if self.authors.important():
            return True
        if self.abstract != None and self.abstract.important():
            return True
        if self.code_type != None and self.code_type.important():
            return True
        return False
    def parse(self):
        """ Analyse le document. """
        self.parseStructure()
        self.splitDocCode()
        self.parseChunks()
        #self.resolveReferences()
    def formatText(self, line_length = DEFAULT_LENGTH):
        r = u""
        if self.title.important():
            r += "\n"
            r += self.title.formatText(line_length)
            r += "\n"
        if self.name != None:
            r += "\n"
            for i in self.getPosition()[1:]:
                r += "="
            r += " "+self.name
            r += "\n"
        r += "\n"
        if self.authors.important():
            r += self.authors.formatText(line_length)
        if self.code_type != None:
            r += u"~Code "+self.code_type+"\n"
        r += "\n"
        if self.abstract != None:
            r += "\n"
            r += "\n"+u"~Abstract~".center(line_length)+"\n\n"
            indent = u""
            for i in range(line_length*1/16):
                indent += u" "
            for i in self.abstract.formatText(int(line_length*7/8)).split("\n"):
                r += indent + i + "\n"
            r += "\n"+u"~~~".center(line_length)+"\n\n"
        if self.introduction.important():
            r += "\n"
            r += self.introduction.formatText(line_length)
            r += "\n"
        for section in self.sections:
            r += "\n"
            r += section.formatText(line_length)+"\n\n"
        # On remplace les doubles lignes vides par des lignes vides uniques
        mode = "doc"
        text = u""
        old = None
        for i in r.split("\n"):
            if mode == "code":
                text += i+"\n"
                if i != "" and i[0] == ">":
                    mode = "doc"
                    text += "\n"
                    old = ""
            else:
                if not (old == "" and i.strip() == ""):
                    if i != "" and i[0] == "<":
                        mode = "code"
                    text += i+"\n"
                old = i.strip()
        return text
    def outputHTML(self, top = True):
        r = u""
        if top:
            r += u"<!doctype html><head><meta charset=\"utf-8\"><style>div{border: 1px solid red; margin: 10px;}</style>"
            if self.title.important():
                r += self.title.outputHTMLTitle()+"\n"
            r += u"</head><body>\n"
        if self.title.important():
            r += self.title.outputHTML()+"\n"
        if self.name != None:
            r += "\n"
            p = self.getPosition()[1:]
            r += "<h"+str(len(p))+">"
            for i in p:
                r += str(i)+"."
            r += " "+self.name
            r += "</h"+str(len(p))+">"
            r += "\n"
        r += "\n"
        if self.authors.important():
            r += self.authors.outputHTML()
        if self.code_type != None:
            r += u"<div class=\"codetype\">Projet codé majoritairement en "+self.code_type+"</div>\n"
        r += "\n"
        if self.abstract != None:
            r += "\n<div class=\"abstract\">"
            h = "h"+str(len(self.getPosition()))
            r += "\n"+u"<"+h+u">Résumé</"+h+">"+"\n\n"
            r += self.abstract.outputHTML(False)
            r += "</div>"
        if self.introduction.important():
            r += "\n"
            r += self.introduction.outputHTML()
            r += "\n"
        for section in self.sections:
            r += "\n"
            r += section.outputHTML(False)+"\n\n"
        if top:
            r += "</body></html>"
        return r

d = Document()
d.fromFile(sys.argv[1])
d.parse()
#print d.formatText()
print d.outputHTML()
#d.debugDisplay()

