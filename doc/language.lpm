= The LPM markup language

[Syntax Basics] 

== Syntax Basics

There are many types  of  tags  in  the  LPM language. Lightweight tags,
meant to  format  the  text,  commands,  that  will  execute  actions at
document  generation,  and  block  tags,  enabling  us  to  define  text
blocks. 

=== Blocks

The most basic mean to define a  block  is to left a blank line beetween
to text blocks: 

<Code (lpm): 
Here is a text block.

And a second text block,
spanning two lines.

And a third text block.
>

We  call  those  text  blocks  “paragraphs”.   When  the  file  will  be
formatted, the blocks lines will  be  merged  if  the  result is not too
long.* Thus, the example above will become, after formatting: 

<Code (lpm): 
Here is a text block.

And a second text block, spanning two lines.

And a third text block.
>

The second block is now one single  line.  In contrast, if a line is too
long, a line feed will be added. 

There are other means to define  blocs.  When  we create a list, or when
we insert  a  code  block,  we  create  blocks,  and  their  behavior is
different from the paragraphs one. 
 *: The source file of  the  documentation  is  formatted  to  fit in 72
    columns (72  characters  max  in  a  line).  The  paragraph  text is
    justified. Code blocks are not changed,  even  if they do not fit in
    72 characters.

=== Commands

Commands fit on one line. They  force  the  end  of a paragraph, even if
there is no blank line  beetween  them  and said paragraph. They usually
begin with the character <<lpm>\~>*. A  command  can enable us to define
a document data (source code  language,  authors…),  or to include other
files at this point of the text. Here is an example of commands: 

<Code (lpm): 
~code python

This is a pararaph
~include test.txt
>

In  that  example,  the  paragraph  doesn't  merge  with  the  following
command, even if the line is not  too  long. That is: **a command stay a
command, alone on a line**. 
 *: But not always. Commands  about  references  usually  begin with the
    same symbole as the one used to refer to them.

=== Lightweight Tags

Lightweight tags are tags found inside  lines.  There can be many on one
line. Lightweight tags act  inside  a  paragraph.  The  can  put text in
bold, italic, define links… And  all  of  that without deteriorating the
text with a characters overflow. Here is an example: 

<Code (lpm): 
This is a **bold text** followed by a reference to a footnote.*
>

=== The Simple Form, and the Complete Form of the language

The markup language's goal  is  to  make  the  source  documents easy to
read. To this  end,  characters  are  used  to  “draw” text decorations.
That way is aesthetic, but not nice  to  write  on our own. So, for some
markup, there is  an  abbreviated  form,  said  “simple”,  that  will be
transformed into the “complete”  form  by  our  program, more pretty. As
an example, we write the book title like that (simple form): 

<Code (lpm): 
**
* A title
**
>

Or, on a more heavy fashion: 

<Code (lpm): 
***********
* A title *
***********
>

And the software will center the title, thus giving us: 

<Code (lpm): 
                             ***********
                             * A title *
                             ***********
>

Those three means of writing a  title  are absolutely equivalent for our
tool, and are only there to make our life easier. 

== Document Structure

A document  as  a  title,  one  or  many  authors,  a  license,  and  an
abstract. In addition to that,  it  is  composed  of many sections, that
structure the document. 

=== The Title

The title is the title of  the  document  (tautology?).  It has to be at
the beginning of the said document.  It  is  written in a star frame. If
it is several lines long, the frame  is  as wide as the widest line, and
other lines are centered. 

<Code (lpm): 
               *****************************************
               *            Document Title             *
               *                                       *
               * This is a test document, with a title *
               *                                       *
               *****************************************
>

It is possible to simplify the  title,  at redaction time, by marking it
as follow: 
 - A line containing  at  least  two  stars,  and  nothing  else (except
 ' maybe  some  spaces  before  and  after  the  line),  will  mark  the
 ' beginning of the title.
 - After that, all lines begin  with  a  star,  then  the text. The last
 ' star of the line is ignored (as  it  is  considered to be part of the
 ' frame). If you want a line  ending  with  a  star (in addition to the
 ' one of the frame), you will have to put two stars.
 - After all these lines, a new  line  containing two stars or more, and
 ' nothing else, mark the end of the title.

So, a simplified title looks like that: 

<Code (lpm): 
**
* Document Title
*
* This is a test document, with a title
*
**
>

=== The Abstract

We begin the  abstract  with  the  command  <<lpm>\~abstract\~>. We then
write a bunch of paragraphs,  then  close  the abstract with the command
<<lpm>\~\~\~>. 

<Code (lpm): 
~abstract~
This is an abstract of our document.

With **two** paragraphs!
~~~
>

Once  formatted,  the  command  <<lpm>\~Abstract\~>  is  centered,  it's
first letter capitalized. The <<lpm>\~\~\~>  that  close the abstract is
centered  too.  The  paragraphs  of   the   abstract  are  shorter,  and
indented, like here: 

<Code (lpm): 
                               ~Abstract~

    This is an abstract of our document.

    With **two** paragraphs!

                                  ~~~
>

=== The License

The license format is  modeled  after  the  abstract  one, but using the
<<lpm>\~License\~> instead of the <<lpm>\~Abstract\~> one. 

<Code (lpm): 
                               ~License~

    __**LRL Recursive License**__

    //Copyright Tartempion © 1842//

    Permission is granted  to  use,  copy, modify and/or distribute
    this work as long as:

     # You follow the license

    This license is under LRL Recursive license.

                                  ~~~
>

=== The Author(s)

We  can  specify   the   authors   of   the   document   thank   to  the
<<lpm>\~authors> command.  That  command  can  appear  many  times,  and
authors will be grouped and  displayed  under  the title. If the command
appear many times, after formatting,  it  will  again appear many times.
We think that if it as  been  typed  more  than  once, there is a reason
and we should not merge the commands. 

<Code (lpm): 
~authors Ludovic Broutille and Mélanine de Balzac.
>

=== The Project Programming Language

Code blocks will  be  inserted  throughout  the  document.  Those can be
prettified  with  syntax  highlighting,   but   only   if  we  know  the
programming language. We can define  that  language  at each code block,
but to save us from typing it  each  time,  we can also specify the more
used language in  the  document.  We  use  the  command <<lpm>\~code> to
that effect. 

<Code (lpm): 
~code haskell
>

== Paragraphs Format

As said in the part  (__Syntax  Basics__)[Syntax Basics], a paragraph is
defined by a sequence of  non  blank  lines.  A  paragraph begins at the
first non blank line encountered, and stop as soon as it encounters: 
 - lines formatted as lists,
 - lines  containing  commands  like  <<lpm>\~include>  (beginning  with
 ' <<lpm>\~>),
 - lines that mark the beginning of a code block,
 - lines that mark a URL or a footnote,
 - lines that mark the beginning of an important paragraph,
 - lines  that  mark  the   beginning   of   a  section  (starting  with
 ' <<lpm>\=>),
 - blank lines.

=== Text formatting

Inside a paragraph, it is possible  to  use characters that will put our
text in **bold**, //italic//, __underlined__, and --striked--. 

Consequently, the paragraph above looks like that: 

<Code (lpm): 
Inside a paragraph, it is possible  to  use characters that will put our
text in **bold**, //italic//, __underlined__, and --striked--. 
>

=== Links and references

You can also add links to  your  document.  A  link is denoted by square
parentheses, and apply to it's  preceding  word,  or  a group of word if
it is in parentheses (in that  case,  parentheses will not appear in the
generated document). A  link  containing  a  word  is  an intra-document
link. Link to the  outside  world  (internet)  are  denoted by two dots,
and defined at the end  of  the  paragraph with the command <<lpm>\..:>.
Links beginning with <<lpm>\=> are  not  links,  but anchors to which we
can point. Thus, we have: 

<Code (lpm): 
An (outside link)[..], a link to an anchor[an anchor].
..:http://example.org/

Some text.

The anchor[=an anchor] in question.
>

Like the outside links, we can  create  footnotes. To this end, we place
a star (and only one, two  stars  are  to  put text in bold) right after
the word that we want to  comment  on.  The <<lpm>\*:> command will mark
said comment, and be followed on the  same  line  and the next ones by a
paragraph which will be the footnote. 

<Code (lpm): 
My text with* a footnote.
*: //with// is not //whit//.
>

    /!\ To know what footnote or  URL  a reference point to, the /!\
    /!\ software  assign  to  each  footnote  or  URL  a  number /!\
    /!\ (counting  them),  and  a   number  to  each  reference. /!\
    /!\ References to an URL  will  point  to  the  URL with the /!\
    /!\ same number, and it  works  the  same  for footnotes. If /!\
    /!\ you forget a footnote,  there  will  be  a  shift in the /!\
    /!\ references!                                              /!\
    /!\                                                          /!\
    /!\ It is a good idea to  keep  your footnotes and URLs just /!\
    /!\ after the paragraph that  references  them,  but you are /!\
    /!\ not forced to  do  so.  A  note  can  even  precede it's /!\
    /!\ reference, as long  as  the  count  (the  order in which /!\
    /!\ the footnotes  appear)  is  not  changed.  It  would  be /!\
    /!\ unadvised to do so, however…                             /!\

=== Important paragraphs

It can be useful to  emphasize  an  entire  paragraph, like the last one
in  the  previous  section.  To   that   effect,   we  use  the  command
<<lpm>/!\\>. That command will  take  the  following  paragraph and mark
it as  important.  It  is  possible  to  put  two  paragraph  in  a same
important block, by placing that  command  on  the blank line that split
our two paragraphs. Finally, that  block  (yes,  we are marking a **text
block** as important)  has  a  complete  form:  each  line  of the block
begins and ends with that  command.  Like  for the abstracts and license
blocks, the important  block  will  be  shorter  and  indented. So, that
code: 

<Code (lpm): 
/!\An important
paragraph
/!\
/!\And another important paragraph

/!\The two paragraphs above are in 
one block, and this one in another.
>

Will become: 

<Code (lpm): 
    /!\ An important paragraph                                   /!\
    /!\                                                          /!\
    /!\ And another important paragraph                          /!\

    /!\ The two paragraphs  above  are  in  one  block, and this /!\
    /!\ one in another.                                          /!\
>

== List formatting

It is possible  to  create  both  numbered  and  non-numbered lists with
LPM. Numbered lists are entered  as  a  sequence on lines beginning with
<<lpm>\#>, each <<lpm>\#>  being  the  beginning  of  an  element of the
list. Non-numbered lists  are  denoted  by  a  <<lpm>\->, each <<lpm>\->
being the beginning of an element of the list. 

If an element of the list  take  more  than  one line, it is possible to
continue on the next  line,  without  beginning  a  new list element, by
starting the line with <<lpm>\'>  rather  than  with <<lpm>\->. In fact,
a line  beginning  by  <<lpm>\#>  or  <<lpm>\->  and  followed  by lines
beginning with <<lpm>\'> becomes, when  that  first column is removed, a
sequence of text blocks,  that  can  be  lists  (and  so, nested lists),
paragraphs… 

<Code (lpm): 
 - A non numbered list
 - A second element

 # A numbered list
 ' whose first element is on many lines
 # The second element embed a non-numbered list
 ' - First element of a nested list
 ' - Second element of a nested list
 ' ' on many lines
 # Third element has many paragraphs
 '
 ' This is the second paragraph of the third element.
>

== Commandes d'inclusion de fichiers

Plusieurs commandes  permettent  d'insérer  un  autre  fichier  dans  le
document. Ces commandes prennent en  paramètre  le  chemin  et le nom du
fichier à insérer, relatif  à  la  position  du  fichier  dans lequel la
commande apparaît. 

Prenons  comme  exemple,  pour  illustrer  ce  principe,  l'arborescence
suivante : 
 - document.txt
 - includes 
 ' - canard.txt
 ' - coco.txt

Si le fichier //document.txt//  veut  inclure  //canard.txt//, il faudra
utiliser la commande  <<lpm>\~get  includes/canard.txt>.  Maintenant, si
le fichier //canard.txt//  veut  inclure  //coco.txt//,  il utilisera la
commande <<lpm>\~get coco.txt>,  et  non <<lpm>\~get includes/coco.txt>.
Ce qui compte ici est la  position  du  fichier sur lequel on travaille,
et  non  celle  du  fichier  sur  lequel  aura  été  lancé  la  commande
<<sh>lpm>. 

Il est possible d'insérer une  image  dans  la  documentation grâce à la
commande <<lpm>\~image> : 

<Code (lpm): 
~image img/lolcat.jpg
>

On peut aussi insérer un fichier  texte  brut dans la documentation avec
la commande <<lpm>\~include> : 

<Code (lpm): 
~include rfc/rfc1149.txt
>

Enfin, on peut inclure un  fichier  LPM,  qui  sera  lu et formaté avant
d'être ajouté dans la documentation : 

<Code (lpm): 
~get partie-2.lpm
>

Cette  dernière  commande  est  très  importante,  car  elle  permet  de
fractionner la source de la  documentation  en plusieurs petit fichiers,
facilement éditables dans un  éditeur  de  texte.  Elle permet aussi, en
supposant que l'on a un fichier  par  section,  de créer une « table des
matières » dans le fichier  principal,  et  de  régorganiser le document
juste en modifiant l'ordre de ces inclusions. 

Pour finir, nous désirons  parler  d'une  commande  qui  n'inclue pas, à
proprement parler, de fichier  dans  la  documentation, mais plutôt dans
le code source généré. C'est la commande <<lpm>\~copy>. 

<Code (lpm): 
~copy image.jpg data/image.jpg
>

Cette commande  prend  deux  fichiers  en  paramètres.  Elle  copiera le
fichier passé en  premier,  et  dont  le  positionnement  est  relatif à
celui du fichier en cours  d'édition,  dans  le fichier passé en second,
dont la position sera  relative  au  dossier  dans  lequel sera placé le
code source. Les espaces  et  autres  caractères  pouvant poser problème
doivent être échappés avec <<lpm>\\>. 

== Gestion du code

=== Définition des blocs de code

Une fonctionnalité importante du  langage  LPM  est  la  gestion du code
source. Il est ainsi possible  d'inclure  facilement du code source dans
le document : 

<Code (lpm): 
\<code:
import os
print os.getcwd()
\>
>

Qui va donner : 

<Code: 
import os
print os.getcwd()
>

En  plus  de  cela,  il   est   possible   de  préciser  le  langage  de
programmation utilisé dans le bloc de code, ce qui permet : 
 # de préciser, pour le lecteur,  le  langage  de  ce qu'il est en train
 ' de lire,
 # d'appliquer une coloration syntaxique adaptée au langage.

<Code (lpm): 
\<code (haskell):
fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
fib n = fibs !! n
\>
>

Deviendra : 

<Code (haskell): 
fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
fib n = fibs !! n
>

Il est possible de nommer un bloc de code : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
void main(){
	printf("Hello, world!\n");
}
\>
>

Et pour finir, à  l'interieur  d'un  bloc  de  code,  il est possible de
faire référence à un bloc de code nommé : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
void main(){
\	<implémentation de main
}
\>
>

=== Programmation lettrée, la toile de code

Cette dernière fonctionnalité nous ammène  à  aborder  le principe de la
programmation lettrée : nous écrivons de  petits  morceaux de code, dans
lesquels nous incluons des  références  vers  d'autres morceaux de code.
Il est aussi possible de  commencer  un  bloc  de code, puis de rajouter
plus tard du code  dans  celui-ci  en  créant  un  nouveau  bloc de code
portant le même nom.  Cette  manière  de  présenter  le  code, emmêlé et
avec des références, fait  penser  au  Web  et  ses liens hypertexte, et
bien que la programmation lettrée  aie  été  inventée bien avant le Web,
sont auteur avait déjà saisi le  concept  de toile d'idées créée par les
références et nommé son invention Web : la toile. 

Ainsi, avec la collection de blocs de code suivante : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
\>
>

<Code (lpm): 
\<code (c): test.c
void main(){
\	<implémentation de main
}
\>
>

<Code (lpm): 
\<code (c): implémentation de main
printf("Hello, world!");
\>
>

Le morceau de code  //test.c//  sera  réunifié,  puis  la référence vers
//implémentation de main// sera résolue  et  remplacée par le morceau de
code portant ce nom.  Toutes  les  lignes  du  code  ainsi inséré seront
indentées  d'autant  de  caractères  que  ce  qui  précède  la  commande
référençant  le  bloc.   Cette   fonctionnalité   est   nécessaire  pour
permettre d'obtenir  un  code  source  lisible  d'une  part,  et d'autre
part, pour supporter  certains  langages  dans  lesquels l'indentation a
un sens  (il  serait  impossible  d'écrire  du  python  en programmation
lettrée sans ça). 

Afin de générer le code source,  le  programme  va regarder les blocs de
code nommés. Pour ceux  qui  n'ont  jamais  été référencés, le programme
considère qu'ils doivent être sortis  dans  un  fichier texte portant le
nom du bloc de code. 

Dans l'exemple précédent, //test.c//  n'est  jamais  inclu dans un autre
bloc  de  code,  et  un   fichier   sera   donc  créé  portant  ce  nom.
//implémentation de main//, par contre,  est  inséré  dans un autre bloc
de code, et il ne sera donc pas extrait dans un fichier.* 
 *: En l'occurence, il le  sera,  mais  seulement  parce  que le morceau
    dans lequel il est inclu, //test.c//,  est  lui même extrait dans un
    fichier.

=== Morceaux de code dans les paragraphes

Il est possible d'indiquer qu'une  portion  de  texte à l'interieur d'un
paragraphe  est  du  code.   Ceci   permet   d'appliquer  la  coloration
syntaxique à ces morceaux  de  code.  Nous  marquons  un passage de code
dans un  texte  en  l'entourant  des  signes  inférieur  et  supérieur :
<<lpm>\<import os\>>. Il est  possible  de  spécifier  le  langage de ce
morceau de code en ajoutant,  directement  après  le signe inférieur, le
langage     entouré      lui      aussi      des      même      signes :
<<lpm>\<\<C\>printf("Wouhou!")\>>. 

=== Récapitulatif de code

Il peut être utile, après avoir  décrit  un  bloc de code petit à petit,
de présenter un  récapitulatif  de  ce  code.  Deux commandes permettent
d'afficher le code qui a été généré : 

La première commande permet de  rappeler  le  contenu d'un bloc de code,
et affiche tout le code de  ce  bloc,  même si celui-ci était morcelé en
plusieurs blocs portant le même nom : 

<Code (lpm): 
~remain morceau de code
>

La seconde  commande  permet  non  seulement  d'afficher  un  morceau de
code, mais  surtout  d'afficher  celui-ci  sans  aucune  référence  vers
d'autres morceaux de code,  c'est  à  dire  qu'il  les remplace par leur
contenu. Ainsi, utiliser  cette  commande  sur  un  bloc  destiné à être
sortit dans un fichier revient  à  insérer  dans  le document le contenu
de ce fichier.  Mais  il  est  possible,  bien  sûr,  d'insérer juste un
morceau de code,  la  commande  fonctionnant  sur  ceux-ci,  et  non pas
exclusivement sur les blocs destinés à être sortis dans un fichier. 

Cette commande est celle-ci : 

<Code (lpm): 
~display morceau de code
>

== Échappement de caractères

=== Échappement de caractères dans les paragraphes

Lorsque nous utilisons  des  caractères  qui  devraient être interprétés
par LPM, mais que nous  les  voulons  tels  quels,  il est nécessaire de
les échapper. Ceci se  fait  à  la  mode  Unix :  tout caractère précédé
d'un <<lpm>\\> sera rendu tel  quel,  sans être interprété. Par exemple,
<<lpm>\\\*\*> affichera <<lpm>\*\*>.  Pour  un  exemple  plus compliqué,
considéront    l'affichage    du    morceau     de    code    suivant* :
<<lpm>\<\<C\>printf("Wouhou!")\>>. Pour arriver à  ce  résultat, il aura
fallut échapper  les  caractères  spéciaux  dans  le  morceau  de  code,
notamment le <<lpm>\>> qui aurait  fermé  le  bloc sinon. Le code source
de       ce       morceau       de       code       est       celui-ci :
<<lpm>\<\<lpm\>\\\<\\\<C\\\>printf("Wouhou!")\\\>\>>. 
 *: Ceci est un morceau de code LPM, pas un morceau de code C.

=== Échappement de caractères dans les blocs de code

Si une ligne  de  code  commence  par  <<lpm>\<>,  elle sera interprétée
comme une référence vers un  autre  bloc  de  code. Si elle commence par
<<lpm>\>>, elle sera  interprétée  comme  une  sortie  du  bloc de code.
Pour empêcher cela, on peut  échapper  la  ligne,  en la débutant par le
caractère <<lpm>\\>.  Contrairement  à  l'échappement  traditionnel,  ce
caractère, dans les blocs de  code,  va  échapper  la ligne entière, qui
peut ensuite contenir n'importe quoi, et non pas juste un caractère. 

Ainsi : 

<Code (lpm): 
\<code:
import os
\\<coco
\>
>

Va donner : 

<Code (lpm): 
import os
\<coco
>

Et pour afficher  ce  bloc  de  code,  il  a  fallut  échapper  la ligne
commençant  par  <<lpm>\\>,  //non   pas   en   échappant  le  caractère
<<lpm>\\>,  mais  bien  la  ligne   entière//.  Le  code  utilisé  était
celui-ci : 

<Code (lpm): 
\<code (lpm):
\\<code:
import os
\\\<coco
\\>
\>
>

//On voit bien ici que  l'on  n'a  échappé  que  le <<lpm>\\>, et pas le
<<lpm>\\\<>, qui aurait  dû  être  échappé  <<lpm>\\\\\\\<>  (au lieu de
<<lpm>\\\\\<>) si nous échappions caractère  par  caractère et non ligne
par ligne.// 

