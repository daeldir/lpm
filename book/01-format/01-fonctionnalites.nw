\chapter{Description du langage de balisage}
\section{Fonctionnalités}

Le langage de balisage proposé par LPM est
\href{http://fr.wikipedia.org/wiki/Langage_de_balisage_l%C3%A9ger}{un langage
de balisage léger}. Il permet d'écrire un document assez conséquent dans un
éditeur de texte, avec assez peu d'efforts supplémentaires pour la mise en
forme, et un fichier source lisible – et non pas masqué par une quantité
incroyable de balises comme en HTML ou en \LaTeX{}.

Le langage de balisage propose les fonctionnalités de mise en forme suivantes~:
\begin{itemize}
\item définition du titre du livre,
\item définition des auteurs du livre,
\item définition du type de code source par défaut dans le livre (pour la
      coloration syntaxique),
\item définition d'une section résumant le livre,
\item organisation du livre en sections et sous-sections, avec un niveau non
      limité de sous-sections (sous-sous-section,
      sous-sous-sous-[…]-sections…),
\item listes numérotées, non-numérotées, et imbrication des listes,
\item notes de bas de page,
\item mise en valeur de paragraphes importants,
\item liens vers des ressources externes,
\item liens à l'intérieur du document,
\item passage du texte en gras, italique, souligné ou barré,
\item inclusion d'images,
\item inclusion de blocs de code, nommés ou nom, avec possibilité de spécifier
      le langage utilisé dans le code.
\item mise en forme des morceaux de code à l'intérieur des paragraphes de
      documentation,
\item inclusion de fichiers textes, en les interprétant ou non.
\end{itemize}

Le programme a un comportement spécial~: lorsqu'il est lancé sur un fichier,
\sout{celui-ci crie} celui-ci est reformaté pour permettre une lecture plus
agréable du code source. Aussi, certaines fonctions de formatage ont deux
formes~: une forme courte, pour que les auteurs n'aient pas à s'embêter à
taper trop de caractères, et une forme complète, qui correspond à la forme
courte une fois que celle-ci a été tranformée par le programme. Le programme
comprend bien entendu les deux formes, et si nous passions deux fois le même
fichier dans le programme, le fichier résultant du deuxième passage ne serait
pas différent du fichier résultant du premier passage (mais celui-ci pourrait
être différent du fichier original).

Le reformattage du fichier source justifie les paragraphes, et limite leur
taille à 80 colonnes, afin de respecter l'antique loi des quatre-vingt colonnes
si chère à Usenet et aux utilisateurs d'éditeurs en ligne de commande dans une
console. Cette limite n'est plus une contrainte pour les développeurs qui
utilisent un éditeur de texte qui ne facilite pas son respect, parce que notre
programme s'en charge.

Les sections suivantes expliquent comment fonctionne chaque fonctionnalité.

\section{Préambule d'un document}
\subsection{Titre du document}

Le titre d'un document a deux formes. La forme longue est celle-ci~:
<<exemple de code>>=
                               ***************
                               *    Titre    *
                               * du document *
                               *             *
                               ***************
@

Le principe est d'encadrer le titre avec des étoiles, et de centrer ce cadre.
Le texte à l'interieur du cadre, s'il tient sur plusieurs lignes, est lui aussi
centré. Le retour à la ligne n'est ici pas utile, et a pour seul but
d'illustrer ce comportement. La ligne vide n'est pas non plus nécessaire, si ce
n'est qu'elle permet un résultat plus esthétique.

Afin de ne pas s'ennuyer à taper tout ces caractères, nous pouvons abréger ce
marquage de la sorte~:
<<exemple de code>>=
**
* Titre 
* du document
*
**
@

Ici, le titre est marqué entre deux lignes contenant deux étoiles (au minimum),
et toutes les lignes du titre doivent débuter par une étoile. Si une ligne du
titre se termine par une étoile, celle-ci est ignorée.

\subsection{Auteur(s) du document}
Le langage de balisage accepte des commandes. Celles-ci débutent toutes par le
caractère [[~]]. Ainsi, pour indiquer les auteurs du document, nous marquons~:

<<exemple de code>>=
~Authors: Mathurin et sa clique
@

La majuscule n'est pas nécessaire, mais rajoutée par le programme si elle n'est
pas déjà présente. 

\subsection{Résumé du document}
Il est possible d'insérer un petit résumé au début du document. Celui-ci est
indiqué grâce à une commande, mais contrairement à la plupart des commandes qui
n'ont d'effet que sur une ligne, celle-ci prend effet jusqu'à croiser une ligne
contenant [[~~~]] (et uniquement ces trois caractères, plus d'éventuels
espaces).

Voici la forme courte d'un résumé~:
<<exemple de code>>=
~Abstract~
Ceci est un résumé,

avec plusieurs paragraphes
~~~
@

Ce passage sera transformé par le programme et ressemblera à ceci~:
<<exemple de code>>=
                                 ~Abstract~
     Ceci est un résumé,

     avec plusieurs paragraphes
                                     ~~~
@

La commande [[~Abstract~]] se retrouve centrée, ainsi que la fin de bloc
[[~~~]]. Les paragraphes contenus dans ce bloc sont indentés de cinq espaces,
et on une largeur maximum de 70 caractères (il y aura donc la place pour cinq
espaces à la fin de chaque ligne).

\section{Structure du document}
\subsection{Les sections}
Les sections sont notées par une ligne précédée d'un ou plusieurs [[=]]. Chaque
[[=]] représente un niveau de profondeur.

<<exemple de code>>=
= Partie
== Chapitre
=== Section
==== Sous-section
===== Sous-sous-section
@

Il n'y a théoriquement pas de limite de profondeur, mais il est conseillé de ne
pas dépasser cinq niveaux~: c'est la limite pour un document \LaTeX{}. Pour une
sortie HTML, la limite est de six, mais un titre de niveau six n'est pas
vraiment mis en valeur.

Dans le cas d'une sortie \LaTeX{}, le programme détermine automatiquement le
niveau supérieur~: s'il y a cinq niveaux de titre, ils correspondent aux
fonctions de l'exemple précédent. Avec quatre niveaux, le choix est fait selon
la quantité de sous-sections~: s'il y en a beaucoup dans les section (plus de
trois en moyenne), nous conservons les parties, chapitres, section et
sous-section.  S'il y en a moins de trois par section, nous supprimons les
parties et décalons la signification des [[=]], pour ce résultat~:

<<exemple de code>>=
= Chapitre
== Section
=== Sous-section
==== Sous-sous-section
@

La raison en est que les sous-sous-sections ne sont pas numérotées quand on
utilise la classe [[report]], ce qui ne facilite pas la lecture s'il y en a
beaucoup dans une sous-section. Mais nous préférons ne pas utiliser les
parties, et leur substituer les chapitres, si utiliser les sous-sous-sections
ne pénalise pas la lisibilité, car nous n'avons pas forcément besoin d'une
aussi grande séparation que les parties si nous n'avons quasiment jamais de
sous-sous-section.

S'il y a encore moins de niveaux de titre dans le document, nous restons sur un
titre de premier niveau correspondant au chapitre.

\subsection{Les notes en bas de page}
Les notes en bas de page sont notées avec le caractère [[*]] accolé à un mot.
Un paragraphe commençant par [[*:]] correspond au texte auquel il est fait
référence. Nous devinons quelle étoile correspond à quelle note en les
comptant~: la première étoile correspond à la première note, et ainsi de suite.
Pour cette raison, nous pouvons placer le texte des notes avant l'étoile qui
s'y réfère, mais ce n'est pas conseillé, pour des raisons évidentes de
lisibilité. L'usage est de placer le texte des notes juste après le paragraphe
qui contient l'étoile associée.

<<exemple de code>>=

*: Cette note est placée au dessus du texte, et c'est perturbant.

Ce texte fait référence à une note au dessus du texte,* et une note en
dessous.*

*: Cette note est mieux placée, de manière plus logique.
@

Notez que la position des notes dans le fichier source ne change rien à leur
position dans la documentation générée~: la note se trouvera au bas des pages
HTML, ou au pied de la page contenant la référence dans un fichier PDF. Dans le
cas d'un fichier ePub, on pourrait penser garder la note après le paragraphe
qui y fait référence.


\subsection{Les inclusions de fichier}

Nous pouvons inclure des fichiers dans le document, afin de rendre celui-ci
modulaire, un gigantesque fichier texte n'étant pas pratique à maintenir. Il
existe deux modes d'inclusion de fichier~:

<<exemple de code>>=
~Include: chemin/vers/fichier/nom_du_fichier.txt
@

Va inclure le fichier de manière verbatim dans notre document. Cette commande
peut être utile pour inclure un texte contenant beaucoup de balises que LPM
interprète mais que nous voulons telles-quelles, sans pour autant nous embêter
à les échapper. 

Il existe cependant une commande bien plus utile~:

<<exemple de code>>=
~Get: chemin/vers/fichier/nom_du_fichier.txt
@

Cette commande va lire le fichier, et interpréter ses balises et commandes.
Entre autre, si le fichier inclut comprend lui même la commande [[~Get:]], il
va inclure d'autres fichiers, de manière récursive. Cette commande est très
utilisée pour découper notre livre en plusieurs fichiers (un fichier contenant
le préambule et la table des matières, un fichier par partie, référençant les
fichiers des chapitres…).


\section{La mise en forme du texte}
\subsection{Le gras, l'italique, le souligné et le barré}
Le texte peut être mis en gras, italique, souligné ou barré. Il est difficile
de marquer la sémantique voulue en ASCII, l'apparence étant bien plus évidente.
Nous n'utilisons donc pas des commandes telles que l'emphase (italique) ou
l'emphase forte (gras), mais directement l'apparence voulue. Lors de l'export
HTML, il ne sera pas supposé de la volonté de l'auteur, et l'italique ne sera
pas transformé en emphase, mais en un [[<span>]] italique. Ce choix est fait
afin de permettre une plus grande liberté à l'auteur~: en effet, les langages
de balisage léger qui font le choix d'utiliser de la sémantique plutôt que de
l'apparence se retrouvent limités au gras et à l'italique, tandis que souligner
est une fonctionnalité bien pratique mais dont le sens n'est pas unique (et
nous proposons de pouvoir barrer le texte tant qu'on y est, parce que ça ne
nous coûte pas grand chose et que ça peut toujours servir).

Sans plus attendre, voici comment créer ces mises en formes~:\footnote{Vous
remarquerez que la commande pour barrer le texte ne prend qu'un seul signe
moins de chaque côté du texte… \textbf{C'est une erreur}~: le système de
programmation lettrée que nous utilisons actuellement est basé sur \LaTeX{}, et
dans ce cas précis, les deux moins qui se suivent sont interprétés par \LaTeX{}
même dans les portions de code (ce n'est pas corrigeable facilement, puisque
les autres fonctions de \LaTeX{} qui permettraient d'éviter ce problème sont
inopérantes dans ce contexte, et que de toute façon, elles abimeraient le code
source à extraire. Il faut bien sûr lire $--barré--$ et non $-barré-$.}

<<exemple de code>>=
Ceci est un texte contenant du **gras**, de //l'italique//, du __souligné__ et
du --barré--.
@

\subsection{Les listes}
\subsubsection{Les listes numérotées}
Les listes numérotées sont des suites de paragraphe commençant par un [[#]]~:
<<exemple de code>>=
# Premier élément de ma liste numérotée
# Second élément
# Troisième élément…
@

\subsubsection{Les listes non numérotées}
Les listes non-numérotées, elles, sont des suites de paragraphe commençant par
un [[-]]~:
<<exemple de code>>=
- Premier élément de ma liste non-numérotée
- Second élément
- Troisième élément…
@

\subsubsection{L'imbrication des listes}
Nous pouvons imbriquer des listes, en doublant, triplant et plus le symbole de
liste~:
<<exemple de code>>=
- liste de premier niveau
- - liste de deuxième niveau
- - deuxième élément de la liste de deuxième niveau
- deuxième élément de la liste de premier niveau
@

Nous pouvons aussi imbriquer des listes numérotées dans des listes non
numérotées, et inversement~:
<<exemple de code>>=
# Liste numérotée, premier niveau, premier élément
#- Liste non-numérotée, second niveau, premier élément
#-# Liste numérotée, troisième niveau, premier élément
#- Liste non-numérotée, second niveau,  second élément
# Liste numérotée, premier niveau, second élément
## Liste numérotée, second niveau, premier élément
## Liste numérotée, second niveau, second élément
@

\subsection{Les liens}
\subsubsection{Les liens vers une ressource externe}
Les liens vers les ressources externes fonctionnent comme les notes de bas de
page, excepté que le lien est marqué par la suite de caractères [[[..]]] plutôt
qu'une étoile~:

<<exemple de code>>=
Ceci est un texte, et voici un lien[..].

[..]: http://example.org/
@

Les références vers des liens sont résolues de la même manière que les notes en
bas de page, en comptant, et les mêmes remarques s'appliquent (on peut mettre
la référence n'importe où, mais il est préférable de la placer après le
paragraphe concerné).

\subsubsection{Les liens vers une partie du document}
Le lien présenté si dessus est comme un lien «~anonyme~»~: il n'a pas de nom,
et nous devons le préciser plus loin. Il existe des liens précis. Ceux-ci
permettent de se diriger vers une autre partie du document en cours, marquée
par une ancre. On remplace alors les deux points par le nom de cette ancre~:
<<exemple de code>>=
Ceci est un lien vers une ancre[la_bas].
@

\subsubsection{Les ancres}
Pour définir une ancre, nous utilisons une synthaxe relativement semblable aux
liens, afin de s'y retrouver. Une ancre est comme un lien, mais dont le nom
commence par le symbole [[=]]. L'idée est de \emph{définir} un lien~:
<<exemple de code>>=
L'ancre « la_bas » pointe ici[=la_bas].
@

\subsubsection{Mettre un lien sur un groupe de mots}
Il est aussi possible de mettre un groupe de mots, plus qu'un mot, en lien.
Pour ce faire, nous mettons le groupe de mots entre parenthèses. Celles-ci
n'apparaîtront pas dans le deocument final.
<<exemple de code>>=
Tout le texte suivant (est en lien)[la_bas].
@

\subsection{Les images}
Une commande permet d'insérer une image dans le document final. Celle-ci sera
centrée et seule sur sa ligne. Elle prendra le plus de largeur possible dans la
page, tout en laissant les blancs nécessaires, et surtout, ne se
redimensionnera pas au point de perdre en qualité (seulement des ratios de zoom
ronds, pas d'agrandissement menant montrant les pixels).

<<exemple de code>>=
~Image: chemin/vers/fichier/image.jpg
@

\subsection{Les notes importantes}
Il est possible de marquer une portion de texte comme importante. Cette portion
sera mise en valeur dans un encadré. Nous notons cette portion comme cela~:

<<exemple de code>>=
/!\ Ceci est un passage important
@

La balise [[/!\]] s'applique à tout un paragraphe. Si nous voulons plusieurs
paragraphes dans un seul encadré, il faut noter la ligne blanche entre les deux
paragraphes comme importante~:
<<exemple de code>>=
/!\ Ce paragraphe et le suivant
/!\
/!\ sont dans un même encadré.

/!\ Mais celui-ci est dans un autre encadré.
@

\section{Le code source}
L'objectif de la création de ce nouveau langage de balisage léger est bien
entendu la facilitation de la programmation lettrée. Pour cette raison, nous ne
pouvons pas nous passer d'une balise pour inclure du code source. Nous devons
aussi proposer un moyen de définir la coloration syntaxique appliquée au code,
et surtout, taper du code source ne doit pas être fatiguant\footnote{Certains
langages, comme Markdown ou reStructuredText demandent d'indenter le code
source pour pouvoir deviner quand commence et finit le bloc de code. D'autres
langages ne proposent même pas d'insérer du code. Dans tout les cas, nous ne
pouvons pas nommer les blocs de code.}.

\subsection{Les morceaux de code}
Un morceau de code est marqué ainsi~:
<<exemple de code>>=
<Code:
/* Mon code source */
>
@

La balise [[<Code:]] débute le morceau de code, et celui-ci se termine par un
[[>]] seul sur une ligne.

Nous pouvons définir le langage du code source entre parenthèse, de la manière
suivante~:
<<exemple de code>>=
<Code (python):
import os, sys
print "C'est du python"
>
@

Nous pouvons nommer un morceau de code en plaçant du texte après les deux
points de la commande~:
<<exemple de code>>=
<Code (C): test.c
#include <SDL.h>
>
@

Il est possible de faire référence à un autre morceau de code, si la ligne
commence par [[<]]~:
<<exemple de code>>=
<Code (python):
def a():
    <définition de a()
a()
>

un peu de texte

<Code: définition de a()
print "coco"
>
@

Lorsque nous incluons du code dans un autre morceau de code, nous l'indentons
de la même manière que l'indentation de la commande qui a inséré le code.

Un code nommé auquel il n'est jamais fait référence est un code qui sera
extrait du fichier de documentation pour donner le code source final.

\subsection{L'apparence du code}
Le programme propose d'appliquer dans la documentation finale une coloration
syntaxique au code source afin de rendre celui-ci plus lisible.

La coloration syntaxique utilisée pour afficher le code est devinée de la
manière suivante~:
\begin{itemize}
\item d'abord, nous déterminons si le type de code est précisé dans la balise
      [[<Code]],
\item ensuite, si ce n'est pas le cas, nous déterminons le type de code à
      partir du type du code dans lequel ce code sera inséré,
\item si le code est inséré dans des morceaux de code de plusieurs types, le
      premier morceau à y faire référence a la priorité,
\item si le type de code n'a pas pu être déterminé, le code est coloré avec la
      coloration syntaxique par défaut.
\end{itemize}

La coloration syntaxique par défaut peut être changée avec la commande 
[[~Code: nom_du_langage]].

\subsection{Le code dans les paragraphes}
Il est possible d'insérer du code dans les paragraphes, pour de courtes
commandes. Celles-ci seront présentées comme du code, et la coloration
syntaxique s'y appliquera. Nous incluons du code dans un paragraphe de cette
manière~:
<<exemple de code>>=
Ceci est un paragraphe avec <printf("du code %s", "en c")>.
@

Il est possible de définir la coloration syntaxique d'un morceau de code de ce
type en la plaçant entre [[<>]], au début du morceau de code~:
<<exemple de code>>=
Dans ce paragraphe, nous décollons : <<python>import antigravity>
@

\section{Échappement}
Puisqu'une partie des caractères utilisés va modifier l'apparence du texte, il
est nécessaire de pouvoir échapper ces caractères, afin de permettre
l'utilisation de ces caractères \emph{sans} qu'ils aient d'effet.

Il y a deux types d'échappement~:
\begin{itemize}
\item l'échappement de caractère, disponible dans toutes les portions de documentation (code source dans les paragraphes comprit),
\item l'échappement de ligne, disponible exclusivement dans les portions de code source, et seul à pouvoir avoir un effet.
\end{itemize}

\subsection{L'échappement de caractère}
À la manière d'Unix, le caractère [[\]] permet d'échapper un caractère, quel
qu'il soit. Il n'y a pas de signification spéciale à certaines associations de
[[\]], ainsi, [[\n]] n'affichera pas un retour à la ligne, mais un [[n]]. Si
l'intérêt est ici limité, le [[\]] devient beaucoup plus intéressant pour
échapper des commandes. Voici quelques exemples~:
<<exemple de code>>=
Ce texte n'est pas \**gras\**.
Ces étoiles le sont, par contre : **\*\***

On affiche du code dans les paragraphes ainsi : @<<lpm>\<\<langage\>code\>>

Voici comment insérer une image~:
\~Image: image.png
@

Cet échappement est très utile pour décrire le langage de balisage léger lui
même, puisqu'on écrit des commandes mais qu'on ne veut pas qu'elles soient
interprétées, mais affichées.

\subsection{L'échappement de ligne}
Dans les portions de code, aucune commande n'est executée. Nous n'avons donc pas à les échapper. Les seuls commandes ayant un effet sont~: 
\begin{itemize}
\item l'inclusion d'un morceau de code avec [[<nom du morceau]],
\item et la fin du code [[>]].
\end{itemize}

Ces deux commandes sont toujours seules sur leur ligne. Pour échapper ces
commandes, nous commençons la ligne par [[\]]. Si une ligne dans le code source
doit commencer par [[\]], nous échappons ce [[\]] avec un autre [[\]]. La règle
est la suivante~: toute ligne commençans par un [[\]] le voit supprimé, le
reste étant considéré sans interprétation.

<<exemple de code>>=
Nous incluons du code ainsi~:
<Code (lpm):
\<Code:
le code
\>

\\ Cette ligne commence par \
\\\ Cette ligne commence par \\
>
\\\ Cette ligne commence par \ (Nous ne sommes plus dans un portion de code et
échappons donc caractère par caractère. Ainsi, nous affichons le deuxième \, et
l'espace qui suit le troisième \. Dans la documentation générée, ce passage est
incompréhensible car tout les \ auront disparus.).

@

\section{Fonctionnalitées futures}
Les fonctionnalités présentées ici sont le minimum vital pour l'écriture d'un
programme en programmation lettrée. À l'avenir, il pourra être utile de
rajouter d'autres commandes, pour permettre la création de tableaux,
l'inclusion de formules de maths… Toute suggestion est la bienvenue et sera,
nous l'espérons, inclue dans le langage à plus ou moins long terme.


