= The LPM Command

The software is easy to use:  we  launch the <<sh>lpm> command, followed
by the  name  of  our  documentation.  We  only  give  one  file  to the
command, if the document is  splitted  in  many files, the software will
fetch them automatically. 

The command does three things: 
 - It creates an HTML  file  with  nicely  formatted documentation. It's
 ' name is the same as the  one  given  as argument to the command, with
 ' the //.html// file extension appended.  That  file  is created in the
 ' current directory (where LPM as been called).
 - It creates  a  directory  //src//  containing  all  the  source files
 ' extracted  from  the   documentation.   Subfolders   are  created  if
 ' required. That directory also is in the current directory.
 - Finally, it  creates,  for  each  documentation  file,  a  //.clean//
 ' file, with  equivalent  content,  but  nicelly  formatted  (justified
 ' text,  important  blocks   indented,   centered   title,  72  columns
 ' lines...). Ideally,  that  //.clean//  should  replace  the  original
 ' file. For now, it  is  advised  to  check  the //.clean// content, as
 ' there can be lost  content  if  your  file  had  syntax errors. Also,
 ' note that if your file  is  already  formatted,  that is, there is no
 ' difference  beetween  your  file   and   the  output  //.clean//,  no
 ' //.clean// is created.

With a graphical environment where  drag  and  drop is implemented*, you
can, if  you  want,  not  use  the  command  line,  and  just  drop  the
documentation file on the software icon.  As  it only need one argument,
the name of the  file  to  extract,  everything  should  go according to
plan. 
 *: That feature is really  useful  on  environments like Windows, where
    the command line is awful.

It is possible to tell  to  the  software  to only perform some actions.
Base   actions   are   “surprising”:   //WTF//.   “**W**”   stands   for
“**Weave**”. Weaving is  the  action  to  create  the HTML documentation
file from  our  source  file.  “**T**”  stands  for  “**Tangle**”.  That
action take our straightforward  source  code,  organized  in a way that
please our brain, and entangle  it,  making  it  less pleasant for human
reading, but understandable  by  the  computer.  Finally, “**F**” stands
for “**Format**”, which is  the  action  of  creating  a //.clean// file
for each  documentation  source  file,  containing  a  nicely  formatted
source. 

Three  more  actions  are   possible:   “**A**”   will  “**Apply**”  the
formatted sources: it  will  replace  original  source  documentation by
formatted source documentation. Use that  command  only  if you are sure
that your file as been correctly  parsed*,  and  that no content is lost
in the //.clean//.  “**C**”  will  “**Clean**”  your  current directory,
that is, remove **all** of the  files  generated by the LPM command. LPM
knows what files to  remove  because  it  always  use  the same name and
path conventions.  It  remove  files  blindly:  do  not  modify  a  file
generated by LPM,  modifications  will  be  lost!  Finally, “**M**” will
“**Monitor**” your source code: each  time  you  modify  a file and save
it, it will extract again the  source  code and documentation (and apply
the //.clean//s if you asked for it). 
 *: A //.clean// is well formatted  only  if  it  is  the same, word by,
    word, as the original source  file,  which  will  not be the case if
    the former has syntax  errors:  the  //.clean// being generated from
    the parsed representation of  the  document,  parsing errors will be
    reflected in the //.clean//.  In  the  worst case, entire paragraphs
    can disappear*. A syntax error  on  your  side  can be considered by
    the program  as  correct,  but  parsed  differently  from  what  you
    intended. So, this case is difficult to avoid.
 *: It happened in the first iterations  of  LPM. I did not stumble upon
    that case again,  but  it  may  be  because  I  learned  to avoid it
    rather than because the software has been corrected.

There are two means of telling  to  the  software to change is behavior:
the Unix way, and the “graphical”  way.  The  Unix way is just to append
parameters on  the  command  line.  The  “graphical”  way  is  meant  to
support graphical environment, where  we  cannot  always pass parameters
to the command. In that case,  the  software  analyse it's own name, and
extract from  it  what  it  should  do.  So,  creating  a  link  to  the
executable file can change it's  behavior.  To each option is associated
a word. If that word appear in  the  command  name, it will be as if the
option had  been  passed.  As  said  before,  the  default  behavior  is
“surprising”: <<sh>\-wtf>. The options  <<sh>\-a>  and <<sh>\-c> are not
used by default. Here is a list of the options: 
 - <<sh>\-w>,  //weave// :  create   an   HTML   representation  of  the
 ' documentation.
 - <<sh>\-t>, //tangle// : extract the computer source code.
 - <<sh>\-f>, //format// : format  the  documentation  source files, and
 ' create //.clean// files containing that formatted output.
 - <<sh>\-a>, //apply// : replace  documentation  source  files by their
 ' associated //.clean// (//apply// the formatting)
 - <<sh>\-c>, //clean// : remove all files generated by LPM.

//If we create a  link  to  LPM  named  //tangle//,  only the //tangle//
operation will be performed  when  using  this  link.  We can obtain the
same effect by creating  a  link  //lpm_tangle//,  if  we  want to avoid
conflicts with other commands, like  the  ones  from //WEB// from Donald
Knuth. What matters is that the  file  name **contain** the action word.
We  also  can  create   two   actions   commands,  like,  for  instance,
//format-apply// (at your own risks), or //weave-tangle//.// 

    /!\ The word apparition  order  (and  the options apparition /!\
    /!\ order) is meaningful.  So,  calling  LPM with <<sh>\-ct> /!\
    /!\ options will clean the  sources  and extract them again, /!\
    /!\ whereas the <<sh>\-tc> options  will  extract the source /!\
    /!\ and  remove  them  right  away   (which  is  like  doing /!\
    /!\ nothing, but slower).  The  same  effect/non-effect will /!\
    /!\ be obtained with  a  LPM  command named //clean-tangle// /!\
    /!\ and another one called //tangle-clean//.                 /!\

