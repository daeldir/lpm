[=description du format LPM] 

= Le format de balisage LPM

== Les bases de la syntaxe

Il existe plusieur type de  balises  dans  le  langage LPM.  Les balises
légères,  destinées à formater le texte,  les commandes,  qui permettent
d'effectuer  une  action  lors  de  la  génération  du document,  et les
balises de bloc, qui premettent de définir des blocs de texte. 

=== Les blocs

La manière la plus basique de définir  un  bloc est de laisser une ligne
vide entre deux blocs de texte : 

<Code (lpm): 
voici un bloc de texte

et un second bloc de texte
sur deux lignes

et un troisième bloc de texte
>

On appelle ces blocs de texte  des paragraphes.  Lorsque le fichier sera
reformaté,  les lignes de ces  blocs  seront  fusionnées  si le résultat
n'est  pas  trop  long.  Ainsi,   l'exemple  ci-dessus  deviendra  après
formatage : 

<Code (lpm): 
voici un bloc de texte

et un second bloc de texte sur deux lignes

et un troisième bloc de texte
>

Le second bloc ne fait  plus  qu'une ligne.  Au contraire,  si une ligne
est trop longue, un retour à la ligne sera inséré. 

Il existe d'autres manières  de  définir  des  blocs.  Lorsque l'on crée
une liste,  ou que l'on insère un bloc de code, on crée des blocs,  dont
le comportement est bien entendu différent de celui des paragraphes. 

=== Les commandes

Les commandes  tiennent  sur  une  ligne.  Elles  marquent  la  fin d'un
paragraphe,  même s'il n'y a pas  de  ligne  vide  entre elles et le-dit
paragraphe.  Elles commencent souvent par le caractère  <<lpm>\~>*.  Une
commande peut permettre de  définir  une donnée du document  (langage du
code source,  auteurs…),  ou d'inclure un autre fichier dans ce fichier.
Voici un exemple de commande : 

<Code (lpm): 
~code python

ceci est un paragraphe
~include test.txt
>

Dans cet exemple,  le paragraphe  ne  fusionne  pas avec la commande qui
le suit,  même si  la  ligne  n'est  pas  trop grande.  En effet,  **une
commande reste une commande, seule sur une ligne**. 
 *: Mais  pas  toujours.   Les   commandes   relatives   aux  références
    commencent en général par le  symbole  lié  à l'élément auquel elles
    se réfèrent.

=== Les balises légères

Les balises légères  sont  des  balises  qui  se  trouvent à l'intérieur
d'une ligne.  Il peut y  en  avoir  plusieurs  sur une seule ligne.  Les
balises  légères   agissent   à   l'intérieur   d'un   paragraphe.  Elle
permettent de mettre en gras,  insérer  des liens… Le tout sans dégrader
le texte par un  surplus  de  caractères.  Voici  un  exemple de balises
légères : 

<Code (lpm): 
Ceci est un **texte en gras** suivit d'une référence vers une note de 
bas de page.*
>

=== La forme simple et la forme complète du langage

Le langage de balisage a  pour  objectif  de  rendre  le document source
agréable  à  lire.  Pour  cela,   les   caractères  sont  utilisés  pour
« dessiner » les  décorations  du  texte.  Cette  manière  de  faire est
esthétique, mais peu pratique à écrire à la main.  Aussi,  pour certains
marquages,  il existe  une  forme  abrégée,  dite  « simple »,  qui sera
transformée par  le  programme  en  forme complète,  plus « jolie ».  Le
programme accepte en entrée indépendamment  l'une ou l'autre forme.  Par
exemple,  nous marquons le titre  du  livre  de cette manière  (la forme
simple) : 

<Code (lpm): 
**
* Un titre
**
>

<Code (lpm): 
************
* Un titre *
************
>

Sachant que le programme finit par centrer les titres, ce qui donne : 

<Code (lpm): 
                            ************
                            * Un titre *
                            ************
>

Ces trois manières de noter  un  titre sont absolument équivalentes pour
le programme, et n'existent que pour simplifier la vie du programmeur. 

=== Échappement de caractères

Lorsque nous utilisons  des  caractères  qui  devraient être interprétés
par LPM,  mais que nous les  voulons  tels  quels,  il est nécessaire de
les échapper.  Ceci se fait  à  la  mode  Unix :  tout caractère précédé
d'un  \\  sera  rendu   tel   quel,   sans   être  interprété.  Un  mode
d'échappement spécial existe  pour  les  blocs  de  code,  mais  il sera
détaillé plus tard, avec les blocs de code. 

== Structure d'un document

Un document possède un titre,  un ou plusieurs auteurs,  une licence, et
un résumé.  En plus de cela,  il est composé de plusieurs sections,  qui
permettent de structurer le document. 

=== Le titre

Le titre correspond au titre  du  document.  Il  doit se trouver au tout
début de celui-ci.  Le titre  est  écrit  dans un cadre d'étoiles.  S'il
fait plusieurs lignes,  le cadre a  largeur  de la plus grande ligne, et
les autres lignes sont centrées : 

<Code (lpm): 
                ***************************************
		*        Le titre du document :       *
		*                                     *
		* Ce document est un document de test *
		*                                     *
		***************************************
>

Il est possible de simplifier  le  titre,  lors  de la rédaction,  en le
marquant de la sorte : 
 - Une ligne contenant aux  moins  deux  étoiles,  sans autre caractères
 ' (à part peut-être des espaces  au  début  et  à  la  fin de la ligne)
 ' marque le début du titre.
 - Après cela, les lignes commencent par une étoile,  puis le texte.  La
 ' dernière étoile de la ligne  est  ignorée  (elle est considérée comme
 ' faisant partie du cadre).  Si vous  voulez  avoir une ligne finissant
 ' par une étoile  (en plus de celle du cadre),  vous devrez écrire deux
 ' étoiles.
 - Après toutes ces lignes,  une  nouvelle  ligne contenant deux étoiles
 ' consécutives ou  plus,  et  sans  autre  caractères  marque la fin du
 ' titre.

Ce qui donne le code suivant : 

<Code (lpm): 
**
* Le titre du document :
*
* Ce document est un document de test
*
**
>

=== Le résumé

On débute  le  résumé   avec   la   commande  <<lpm>\~abstract\~>.  Nous
écrivons ensuite une suite de  paragraphes,  puis fermons le résumé avec
la commande <<lpm>\~\~\~>. 

<Code (lpm): 
~abstract~
Ceci est un résumé.

Avec **deux** paragraphes !
~~~
>

Une fois formaté,  la commande <<lpm>\~Abstract\~>  se retrouve centrée,
la première lettre en  capitale.  Le  <<lpm>\~\~\~>  qui ferme le résumé
est lui aussi centré.  Les lignes des  blocs de textes du résumé sont un
peu moins longues, et indentée, pour le résultat suivant : 

<Code (lpm): 
                               ~Abstract~

    Ceci est un résumé.

    Avec **deux** paragraphes !

                                  ~~~
>

=== La licence

Le format de  la  licence  est  calqué  sur  celui  du  résumé,  mais en
utilisant  la  commande  <<lpm>\~License\~>   plutôt   que  la  commande
<<lpm>\~Abstract\~>.  Notez que  « License »  est  écrit  en anglais, et
que contrairement au français,  le  //\[s\]//  se  note avec un **s** et
non un **c**. 

<Code (lpm): 
                               ~License~

    __**Licence Récursive LRL**__

    //Copyright Tartempion © 1842//

    Vous  avez  la  permission  d'utiliser,  copier,  modifier et/ou
    distribuer ce travail aussi longtemps que :
     # Vous respectez la licence

    Cette licence est soumise à la licence LRL

                                  ~~~
>

=== Le ou les auteurs

Il est possible de préciser  le  ou  les  auteurs du document grâce à la
commande  <<lpm>\~authors>.  Cette commande  peut  apparaître  plusieurs
fois,  et les auteurs seront regroupés et affichés sous le titre.  Si la
commande apparaît plusieurs fois,  après  reformatage du document,  elle
apparaîtra toujours plusieurs  fois.  Nous  partons  du  principe que si
vous avez préféré  utiliser  plusieurs  fois  la  commande,  il  y a une
raison. 

<Code (lpm): 
~authors Ludovic Broutille et Melanine Balzac.
>

=== Le langage de programmation du projet

Des blocs de code  seront  insérés  tout  au  long du document.  Ceux-ci
peuvent être mis en valeur  par  la coloration syntaxique,  mais pour ce
faire,  nous devons connaître le langage de programmation utilisé.  Nous
pouvons définir ce langage au  cas  par cas,  mais pour nous épargner de
le faire  à  chaque  fois,  nous  pouvons  aussi  définir  un langage de
programmation par  défaut,  correspondant  au  langage  le  plus utilisé
dans le document. Pour cela, nous utilisons la commande <<lpm>\~code>. 

<Code (lpm): 
~code haskell
>

== Formatage des paragraphes

Comme   dit    dans    la    partie    (__Le    format    de    balisage
LPM__)[description du format  LPM],  un  paragraphe  est définit par une
suite de lignes non-vides.  Un paragraphe  commence  à la première ligne
non-vide rencontrée,  et s'arrête dès  qu'il rencontre une ligne vide ou
une commande.  Les  lignes   succeptibles   de   marquer   la  fin  d'un
paragraphe sont : 
 - les lignes formatées comme une liste,
 - les lignes  contenant   une   commande   du   type   <<lpm>\~include>
 ' (commençant par un <<lpm>\~>),
 - les lignes marquant le début d'un bloc de code,
 - les lignes marquant une url ou une note de bas de page,
 - les lignes marquant un début de paragraphe important,
 - les lignes marquant un début de section (débutant par <<lpm>\=>),
 - les lignes vides.

=== Formatage du texte

À l'intérieur du paragraphe,  il est  possible d'utiliser des caractères
qui vont  mettre  le   texte   **en   gras**,   //en   italique//,  __en
souligné__, et même --en barré--. 

Le paragraphe précédent ressemble donc à ceci : 

<Code (lpm): 
À l'intérieur du paragraphe,  il est  possible d'utiliser des caractères
qui vont  mettre  le   texte   **en   gras**,   //en   italique//,  __en
souligné__, et même --en barré--.
>

=== Liens et références

Il est aussi possible  d'ajouter  des  liens.  Un  lien  est  noté entre
crochets,  et s'applique au mot qui  précède,  ou bien au groupe contenu
dans les  parenthèses  qui  précède  (auquel  cas  les  parenthèses sont
supprimées du texte dans le  document généré).  Un lien contenant un mot
est un lien intra-document.  Les liens  vers  l'exterieur sont notés par
deux points,  puis rappelés  à  la  fin  du  paragraphe avec la commande
<<lpm>\..:>.  Les liens dont le mot commence par  <<lpm>\=>  ne sont pas
des liens,  mais des  ancres  vers  lesquelles  on peut pointer.  Ce qui
donne : 

<Code (lpm): 
Un (lien vers l'exterieur)[..], un lien vers une ancre[une ancre].
..:http://example.org/

Du texte.

L'ancre[=une ancre] en question.
>

Comme les liens vers  l'exterieur,  il  est  possible de créer des notes
de bas de page.  Pour cela,  on  place une étoile  (seule,  deux étoiles
correspondant  à  la  mise  en  gras)  à  côté  du  mot  que  l'on  veut
commenter.  La   commande   <<lpm>\*:>   contiendra   le  commentaire en
question,  et  sera  suivit  sur  la  même  ligne  et  les  suivantes du
paragraphe contenant le commentaire. 

<Code (lpm): 
mon texte avec* une note de bas de page.
*: //avec// est un anagramme de //cave//.
>

    /!\ Pour savoir quelle  note  de  bas  de page ou quelle URL /!\
    /!\ correspond à  une  référence,  le  programme  assigne un /!\
    /!\ nombre à chaque note de  bas  de  page ou chaque URL (il /!\
    /!\ les compte),  ainsi qu'un  nombre  à  chaque  référence. /!\
    /!\ Les références vers  une  URL  vont  pointer  vers l'URL /!\
    /!\ auquel le même nombre  a  été  assigné,  et de même pour /!\
    /!\ les notes de bas de  page.  Si  vous oubliez une note de /!\
    /!\ bas de  page,   il   y   aura   un   décalage   dans les /!\
    /!\ références !                                             /!\
    /!\                                                          /!\
    /!\ Il est considéré comme  une  bonne pratique de mettre la /!\
    /!\ note ou l'URL  directement  derrière le paragraphe qui y /!\
    /!\ fait référence,  mais  ce  n'est  pas  obligé.  Une note /!\
    /!\ peut même préceder  le  texte  qui s'y réfère,  tant que /!\
    /!\ le compte  (l'ordre  des  notes)   n'est  pas  perturbé. /!\
    /!\ Toutefois, ce n'est pas vraiment conseillé.              /!\

=== Les paragraphes importants

Il peut être utile de mettre  en  avant un paragraphe,  comme le dernier
paragraphe de la section précédente.  Pour celà,  on utilise la commande
<<lpm>/!\\>.  Cette commande va  considérer  tout  le  paragraphe qui la
suit comme un  paragraphe  important.  Il  est  possible  de mettre deux
paragraphes dans un même  bloc  important  en  plaçant la commande aussi
sur la ligne vide qui les sépare.  Enfin,  dans la forme complète de ces
blocs  (car  oui,  c'est  un  bloc   de   texte  qui  est  marqué  comme
important),  chaque  ligne  du  bloc  commence  par  cette  commande, et
termine aussi par  celle-ci.  Comme  les  résumés  et licences,  le bloc
sera aussi un peu plus court et indenté. Ainsi, ce code : 

<Code (lpm): 
/!\Un paragraphe
important
/!\
/!\Et un autre paragraphe important

/!\Les deux paragraphes précédents sont dans le même bloc, et celui-ci 
dans un nouveau bloc important.
>

Deviendra : 

<Code (lpm): 
    /!\ Un paragraphe important                                  /!\
    /!\                                                          /!\
    /!\ Et un autre paragraphe important                         /!\

    /!\ Les deux  paragraphes  précédents  sont   dans  le  même /!\
    /!\ bloc, et celui-ci dans un nouveau bloc important.        /!\
>

== Formatage des listes

LPM permet   de   créer   des   listes    numérotées   et   des   listes
non-numérotées.  Les listes numérotées  sont  marquées  par une suite de
lignes commençant par  <<lpm>\#>,  chaque  <<lpm>\#>  marquant  le début
d'un élément de la  liste.  Les  listes non-numérotées sont marquées par
une ligne  commençant  par  <<lpm>\->,   chaque  <<lpm>\->  marquant, de
même, le début d'un élément de la liste. 

Si un élément de la liste tient  sur  plus d'une ligne,  il est possible
de continuer sur la ligne  suivante,  sans  débuter de nouvel élément de
liste,  en commençant la ligne par  <<lpm>\'>  plutôt que par <<lpm>\->.
En réalité,  une ligne commençant par <<lpm>\->  ou <<lpm>\#>  et suivie
de lignes commençant par  <<lpm>\'>  devient,  si  on  enlève le premier
caractère  de  ces  lignes,  une  suite  de  blocs  de  textes,  pouvant
contenir d'autres listes, des paragraphes… 

<Code (lpm): 
 - une liste non numérotée
 - un deuxième élément

 # une liste numérotée
 ' le premier élément tenant sur plusieurs lignes
 # Le deuxième élément contient une liste non-numérotée
 ' - Premier élément d'une sous-liste
 ' - Deuxième élément de la sous-liste
 ' ' sur plusieurs lignes
 # Le troisième élément contient deux paragraphes
 '
 ' C'est le deuxième paragraphe du troisième élément.
>

== Commandes d'inclusion de fichiers

Plusieurs  commandes  permettent  d'insérer  un  autre  fichier  dans le
document.  Ces commandes prennent en  paramètre  le  chemin et le nom du
fichier à insérer,  relatif  à  la  position  du  fichier dans lequel la
commande apparaît. 

Prenons  comme  exemple,  pour  illustrer  ce  principe,  l'arborescence
suivante : 
 - document.txt
 - includes 
 ' - canard.txt
 ' - coco.txt

Si le fichier //document.txt//  veut  inclure //canard.txt//,  il faudra
utiliser la  commande  <<lpm>\~get includes/canard.txt>.  Maintenant, si
le fichier //canard.txt//  veut  inclure  //coco.txt//,  il utilisera la
commande <<lpm>\~get coco.txt>,  et non  <<lpm>\~get includes/coco.txt>.
Ce qui compte ici est la  position  du  fichier sur lequel on travaille,
et non  celle  du  fichier  sur  lequel   aura  été  lancé  la  commande
<<sh>lpm>. 

Il est possible d'insérer  une  image  dans  la documentation grâce à la
commande <<lpm>\~image> : 

<Code (lpm): 
~image img/lolcat.jpg
>

On peut aussi insérer un fichier  texte  brut dans la documentation avec
la commande <<lpm>\~include> : 

<Code (lpm): 
~include rfc/rfc1149.txt
>

Enfin,  on peut inclure un fichier  LPM,  qui  sera lu et formatté avant
d'être ajouté dans la documentation : 

<Code (lpm): 
~get partie-2.lpm
>

Cette  dernière  commande  est  très   importante,  car  elle  permet de
fractionner la source de  la  documentation en plusieurs petit fichiers,
facilement éditables dans  un  éditeur  de texte.  Elle permet aussi, en
supposant que l'on a un  fichier  par section,  de créer une « table des
matières » dans le  fichier  principal,  et  de régorganiser le document
juste en modifiant l'ordre de ces inclusions. 

Pour finir,  nous désirons  parler  d'une  commande  qui n'inclue pas, à
proprement parler,  de fichier dans  la documentation,  mais plutôt dans
le code source généré. C'est la commande <<lpm>\~copy>. 

<Code (lpm): 
~copy image.jpg data/image.jpg
>

Cette commande  prend  deux  fichiers  en  paramètres.  Elle  copiera le
fichier passé  en  premier,  et  dont  le  positionnement  est relatif à
celui du fichier en cours  d'édition,  dans  le fichier passé en second,
dont la position sera  relative  au  dossier  dans  lequel sera placé le
code source.  Les espaces  et  autres  caractères pouvant poser problème
doivent être echappés avec \\. 

== Gestion du code

=== Définition des blocs de code

Une fonctionnalité importante du  langage  LPM  est  la  gestion du code
source.  Il est ainsi possible d'inclure  facilement du code source dans
le document : 

<Code (lpm): 
\<code:
import os
print os.getcwd()
\>
>

Qui va donner : 

<Code: 
import os
print os.getcwd()
>

En plus  de  cela,   il   est   possible   de   préciser  le  langage de
programmation utilisé dans le bloc de code, ce qui permet : 
 # de préciser,  pour le lecteur,  le langage  de  ce qu'il est en train
 ' de lire,
 # d'appliquer une coloration syntaxique adaptée au langage.

<Code (lpm): 
\<code (haskell):
fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
fib n = fibs !! n
\>
>

Deviendra : 

<Code (haskell): 
fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
fib n = fibs !! n
>

Il est possible de nommer un bloc de code : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
void main(){
	printf("Hello, world!\n");
}
\>
>

Et pour finir,  à l'interieur  d'un  bloc  de  code,  il est possible de
faire référence à un bloc de code nommé : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
void main(){
\	<implémentation de main
}
\>
>

=== Programmation lettrée, la toile de code

Cette dernière fonctionnalité nous  ammène  à  aborder le principe de la
programmation lettrée : nous écrivons  de petits morceaux de code,  dans
lesquels nous incluons des  références  vers  d'autres morceaux de code.
Il est aussi possible de  commencer  un  bloc de code,  puis de rajouter
plus tard du code  dans  celui-ci  en  créant  un  nouveau  bloc de code
portant le même  nom.  Cette  manière  de  présenter le code,  emmêlé et
avec des références,  fait penser  au  Web  et  ses liens hypertexte, et
bien que la programmation lettrée  aie  été  inventée bien avant le Web,
sont auteur avait déjà saisi  le concept  de toile d'idées créée par les
références et nommé son invention Web : la toile. 

Ainsi, avec la collection de blocs de code suivante : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
\>
>

<Code (lpm): 
\<code (c): test.c
void main(){
\	<implémentation de main
}
\>
>

<Code (lpm): 
\<code (c): implémentation de main
printf("Hello, world!");
\>
>

Le morceau de code  //test.c//  sera  réunifié,  puis  la référence vers
//implémentation de main// sera  résolue  et remplacée par le morceau de
code portant ce  nom.  Toutes  les  lignes  du  code ainsi inséré seront
indentées  d'autant  de  caractères  que  ce  qui  précède  la  commande
référençant  le  bloc.   Cette   fonctionnalité   est   nécessaire  pour
permettre d'obtenir  un  code  source  lisible  d'une  part,  et d'autre
part,  pour supporter  certains  langages  dans lesquels l'indentation a
un sens  (il serait  impossible  d'écrire  du  python  en  programmation
lettrée sans ça). 

Afin de générer le code  source,  le  programme va regarder les blocs de
code nommés.  Pour ceux qui  n'ont  jamais été référencés,  le programme
considère qu'ils doivent être  sortis  dans  un fichier texte portant le
nom du bloc de code. 

Dans l'exemple précédent,  //test.c// n'est  jamais  inclu dans un autre
bloc  de  code,  et  un   fichier   sera   donc  créé  portant  ce  nom.
//implémentation de main//,  par contre,  est inséré  dans un autre bloc
de code, et il ne sera donc pas extrait dans un fichier.* 
 *: En l'occurence,  il le sera,  mais  seulement  parce  que le morceau
    dans lequel il est inclu,  //test.c//,  est lui même extrait dans un
    fichier.

=== Échappement de caractères dans les blocs de code

Si une ligne  de  code  commence  par  <<lpm>\<>,  elle sera interprétée
comme une référence vers  un  autre  bloc de code.  Si elle commence par
<<lpm>\>>,  elle sera interprétée  comme  une  sortie  du  bloc de code.
Pour empêcher cela,  on peut  échapper  la ligne,  en la débutant par le
caractère  <<lpm>\\>.  Contrairement  à  l'échappement  traditionnel, ce
caractère,  dans les blocs de code,  va  échapper la ligne entière,  qui
peut ensuite contenir n'importe quoi, et non pas juste un caractère. 

Ainsi : 

<Code (lpm): 
\<code:
import os
\\<coco
\>
>

Va donner : 

<Code (lpm): 
import os
\<coco
>

Et pour afficher  ce  bloc  de  code,  il  a  fallut  échapper  la ligne
commençant  par  <<lpm>\\>,  //non   pas   en   échappant  le  caractère
<<lpm>\\>,  mais  bien  la  ligne   entière//.  Le  code  utilisé  était
celui-ci : 

<Code (lpm): 
\<code (lpm):
\\<code:
import os
\\\<coco
\\>
\>
>

=== Morceaux de code dans les paragraphes

Il est possible d'indiquer qu'une  portion  de  texte à l'interieur d'un
paragraphe  est  du  code.   Ceci   permet   d'appliquer  la  coloration
syntaxique à ces  morceaux  de  code.  Nous  ne  somme alors pas dans un
bloc de code,  et l'échappement  se  fait  cette  fois  à  la mode Unix,
caractère par  caractère.  Nous  marquons  un  passage  de  code dans un
texte   en   l'entourant    des    signes   inférieur   et   supérieur :
<<lpm>\<import os\>>.  Il est  possible  de  spécifier  le langage de ce
morceau de code en  ajoutant,  directement  après le signe inférieur, le
langage     entouré      lui      aussi      des      même      signes :
<<lpm>\<\<C\>printf("Wouhou!")\>>. 

Enfin,  pour  illustrer  l'échappement  caractère  par caractère,  voici
comment    a    été    noté    le     dernier    morceau    de    code :
<<lpm>\<\<lpm\>\\\<\\\<C\\\>printf("Wouhou!")\\\>\>>. 

=== Récapitulatif de code

Il peut être utile,  après avoir décrit un  bloc  de code petit à petit,
de présenter un récapitulatif  de  ce  code.  Deux  commandes permettent
d'afficher le code qui a été généré : 

La première commande permet de rappeler  le  contenu  d'un bloc de code,
et affiche tout le code de  ce  bloc,  même si celui-ci était morcelé en
plusieurs blocs portant le même nom : 

<Code (lpm): 
~remain morceau de code
>

La seconde  commande  permet  non  seulement  d'afficher  un  morceau de
code,  mais surtout  d'afficher  celui-ci  sans  aucune  référence  vers
d'autres morceaux de code,  c'est  à  dire  qu'il  les remplace par leur
contenu.  Ainsi,  utiliser cette commande  sur  un  bloc  destiné à être
sortit dans un fichier  revient  à  insérer  dans le document le contenu
de ce fichier.  Mais  il  est  possible,  bien  sûr,  d'insérer juste un
morceau de  code,  la  commande  fonctionnant  sur  ceux-ci,  et non pas
exclusivement sur les blocs destinés à être sortis dans un fichier. 

Cette commande est celle-ci : 

<Code (lpm): 
~display morceau de code
>

