#!/usr/bin/python2
# -*- encoding: utf-8 -*-

# Initialisation
import sys, codecs, base64, os
from os import path
import pygments
from pygments import highlight
from pygments.lexers import get_lexer_by_name
from pygments.formatters import HtmlFormatter

sys.stdout = codecs.getwriter("utf-8")(sys.stdout) 
sys.stderr = codecs.getwriter("utf-8")(sys.stderr) 

DEFAULT_LENGTH = 72
INDENT = "    "
MARGINS = len(INDENT)

FOOTNOTE = []
NOTEREF = 0 
URLREF = 0
FOOTURL = []
CODE = {}
REFCOUNT = 0

DOCUMENT_LANGUAGE = "text"
COLOR_ERRORS = []
CODEREF_ERRORS = []

# Fonctions utiles
def splitPath(line):
    r = []
    esc = False
    l = ""
    for i in line:
        if esc:
            l += i
            esc = False
        elif i == "\\":
            esc = True
        elif i == " ":
            r.append(l)
            l = ""
        else:
            l += i
    r.append(l)
    return r

def detect_starline(line):
    if len(line) < 2:
        return False
    for c in line:
        if c != "*":
            return False
    return True

def begin(line, begin):
    if len(line) < len(begin):
        return False
    return line[:len(begin)].lower() == begin

def debugDisplay(kind, deep, line = ""):
    indent = ""
    for i in range(deep):
        indent += "'"
    l = "-%s-%s%s" % (kind.ljust(10), indent, line)
    print l[:min(len(l),75)]

def escape(txt):
    r = u""
    for i in range(len(txt)):
        if i == 0 and txt[i] in ["-", "#", "'", "="]:
                r += "\\"
        elif i == 0 and txt[i:i+3] == "..:":
                r += "\\"
        elif i < len(txt)-2 and txt[i:i+2] in ["--", "__", "//", "**"]:
                r += "\\"
        elif txt[i] in ["\\", "*", "<", ">", "[", "]", "~"]:
            r += "\\"
        r += txt[i]
    return r

def refEscape(txt):
    txt = txt.encode("ascii", "replace")
    txt = txt.replace(" ", "_")
    txt = txt.replace("?", "_")
    txt = txt.replace("'", "_")
    txt = txt.replace(",", "_")
    return txt
def addSpaceAfter(line, c, direction):
    l = len(line)
    if direction == 1:
        start = 4
        stop = l-4
    else:
        start = l-5
        stop = 3
    for i in range(start, stop, direction):
        if line[i:i+3] != c+"  " and line[i:i+2] == c+" ":
            return True, line[:i+1]+" "+line[i+1:]
    return False, line
def addSpaceBefore(line, c, direction):
    l = len(line)
    if direction == 1:
        start = 4
        stop = l-4
    else:
        start = l-5
        stop = 3
    for i in range(start, stop, direction):
        if line[i-2:i+1] != "  "+c and line[i-1:i+1] == " "+c:
            return True, line[:i-1]+" "+line[i-1:]
    return False, line

def addSpaceAnywhere(line, direction):
    l = len(line)
    if direction == 1:
        start = 4
        stop = l-4
    else:
        start = l-5
        stop = 3
    spaces = []
    last = ""
    for i in range(start, stop, direction):
        if line[i] == " ":
            if last == " ":
                spaces[-1]["c"] += 1
            else:
                spaces.append({"i":i, "c": 1})
        last = line[i]
    if len(spaces) == 0:
        return False, line
    least = spaces[0]
    for i in spaces:
        if i["c"] < least["c"]:
            least = i
    most = []
    for i in spaces:
        if i["c"] == least["c"]:
            most.append(i)
    c = most[int(len(most)/2)]["i"]
    return True, line[:c]+" "+line[c:]

def addSpace(line, direction):
    r, line = addSpaceAfter(line, ".", direction)
    if not r:
        r, line = addSpaceAfter(line, ",", direction)
    if not r:
        r, line = addSpaceAfter(line, ")", direction)
    if not r:
        r, line = addSpaceAfter(line, "]", direction)
    if not r:
        r, line = addSpaceAfter(line, ">", direction)
    if not r:
        r, line = addSpaceBefore(line, "-", direction)
    if not r:
        r, line = addSpaceBefore(line, "-", direction)
    if not r:
        r, line = addSpaceBefore(line, "(", direction)
    if not r:
        r, line = addSpaceBefore(line, "[", direction)
    if not r:
        r, line = addSpaceBefore(line, "<", direction)
    if not r:
        r, line = addSpaceAnywhere(line, direction)
    return line

def justify(line, length):
    l = len(line)
    direction = 1
    if len(line) < 10:
        return line # We can't justify that as we use only spaces beetween five
                    # characters from the start and to the end of the string.
    while len(line) < length:
        line = addSpace(line, direction).strip()
        direction *= -1
    return line

# Importation
class Code:
    def __init__(self, line):
        """ Contient un morceau de code """
        global CODE
        self.type = "code"
        self.language = None
        self.raw_code = []
        self.code = []
        self.resolved = []
        self.referenced = False
        self.references = []
        self.index = 0

        split = line.split(":")
        language = split[0]
        if "(" in language:
            language = language.split("(")[1]
            if ")" in language:   
                self.language = language.split(")")[0]
        name = ":".join(split[1:])
        if name.strip() != "":
            self.name = name.strip()
            if self.name in CODE:
                CODE[self.name].append(self)
            else:
                CODE[self.name] = [self]
            self.index = len(CODE[self.name])
        else:
            self.name = None

    def append(self, line):
        self.raw_code.append(line)

    def important(self):
        """ Renvoie False si le morceau de code est vide et n'a pas de nom. """
        if self.name != None:
            return True
        for i in self.raw_code:
            # Le strip nous empêche d'écrire des codes anonymes en whitespace.
            # Tant pis.
            if i.strip() != "":
                return True
        return False

    def debugDisplay(self, deep):
        if self.name == None:
            name = u"None"
        else:
            name = self.name
        if self.language == None:
            language = u"None"
        else:
            language = self.language
        debugDisplay("code chunk", deep, "language: "+language+u", name: "+name)
        for i in self.code:
            i.debugDisplay(deep+1)
    def formatText(self, length):
        if self.name == None:
            name = u""
        else:
            name = self.name
        if self.language == None:
            language = u""
        else:
            language = " ("+self.language+")"
        r = u"<Code"+language+": "+name+"\n"
        for i in self.code:
            r += i.formatText(length)
        r += ">\n"
        return r
    def outputHTML(self, remain = False, line = 1):
        global COLOR_ERRORS
        if self.name == None:
            name = u""
            before = u""
            after = u""
        else:
            name = "<span class=\"\codename\"><a id=\""+refEscape(self.name)+str(self.index)+"\">"+self.name+"</a></span>"
            if self.index != 1:
                before = u"<a href=\"#"+refEscape(self.name)+str(self.index-1)+"\"> &lt;-</a>"
            else:
                before = u""
            if self.index < len(CODE[self.name]):
                after = u"<a href=\"#"+refEscape(self.name)+str(self.index+1)+"\"> -&gt;</a>"
            else:
                after = u""
        references = u" "
        for i in self.references:
            references += "<a href=\"#coderef"+str(i)+"\">("+str(i)+")</a> "
        if self.language == None:
            language = u" "
            format_language = DOCUMENT_LANGUAGE
        else:
            format_language = self.language
            language = " <span class=\"codelang\">("+self.language+")</span>"
        if not remain:
            r = u"<div class=\"codechunk\"><div class=\"codehead\">Code"+language+": "+name+before+after+references+"</div>\n"
        else:
            r = u""
        code = u""
        try:
            lexer = get_lexer_by_name(format_language)
        except pygments.util.ClassNotFound:
            if not format_language in COLOR_ERRORS:
                COLOR_ERRORS.append(format_language)
            lexer = get_lexer_by_name("text")
        old_line = line
        begin_line = line
        formatter = HtmlFormatter(linenos=True, linenostart = line, cssclass="source")
        for i in self.code:
            if i.type != "reference":
                code += i.outputHTML()
                line += 1
            else:
                formatter = HtmlFormatter(linenos=True, linenostart = old_line, cssclass="source")
                begin_line = line
                if i.name in CODE:
                    line += len(CODE[i.name][0].resolved)
                if code != "":
                    r += highlight(code, lexer, formatter)
                code = u""
                r += i.outputHTML(remain) % begin_line
                old_line = line
        formatter = HtmlFormatter(linenos=True, linenostart = old_line, cssclass="source")
        if code != "":
            r += highlight(code, lexer, formatter)
        if not remain:
            r += "</div>\n"
        return r
    def resolv(self):
        global CODE
        resolved = False
        self.resolved = self.code
        while not resolved:
            resolved = True
            new_resolved = []
            for i in self.resolved:
                if type(i) != unicode:
                    if i.type == "reference":
                        resolved = False
                        new_resolved += i.resolv()
                    else:
                        new_resolved.append(i.line)
                else:
                    new_resolved.append(i)
            self.resolved = new_resolved
        return self.resolved
    def outputCode(self):
        global CODE
        r = u""
        for i in CODE[self.name]:
            for j in i.code:
                r += j.outputCode()
        return r[:-1]
    
    def parse(self):
        for i in self.raw_code:
            if len(i.strip()) > 0 and i.strip()[0] == "<":
                self.code.append(self.Reference(i))
            else:
                self.code.append(self.Line(i))

    class Line:
        def __init__(self, line):
            """ Crée une ligne sans le retour à la ligne final. """
            if line != "" and line[-1] == "\n":
                line = line[:-1]
            if len(line) > 0 and line[0] == "\\":
                line = line[1:]
            self.line = line
            self.type = "line"
        def debugDisplay(self, deep):
            debugDisplay("codeline", deep, self.line+u"'")
        def formatText(self, length):
            sline = self.line.strip()
            if sline != "" and sline[0] in ["<", ">", "\\"]:
                return "\\"+self.line+"\n"
            else:
                return self.line+"\n"
        def outputCode(self):
            return self.line+"\n"
        def outputHTML(self):
            return self.line+"\n"

    class Reference:
        def __init__(self, line):
            global REFCOUNT
            self.type = "reference"
            self.indentation = ""
            for c in line:
                if c != " " and c != "\t":
                    break
                self.indentation += c
            self.name = line.strip()[1:].strip()
            REFCOUNT += 1
            self.count = REFCOUNT
        def debugDisplay(self, deep):
            debugDisplay("coderef", deep, u"dest: «"+self.name+u"», indent: |]"+self.indentation+u"[>")
        def formatText(self, length):
            return self.indentation+"<"+self.name+"\n"
        def outputHTML(self, remain = False):
            r = "<table class=\"coderef\"><tbody><tr><td><pre>%d</pre><td><pre>"
            r += self.indentation.replace(" ", "&nbsp;").replace("\t", "&nbsp;&nbsp;&nbsp;&nbsp;")
            r += "&lt;<a "
            if not remain:
                r += "id=\"coderef"+str(self.count)+"\" "
            r += "href=\"#"+refEscape(self.name)+"1\">"
            r += self.name.replace("<", "&lt;")
            r += "</a></pre></td></tr></tbody></table>\n"
            return r
        def outputCode(self):
            global CODE
            r = u""
            if self.name in CODE:
                for i in CODE[self.name][0].outputCode().split("\n"):
                    r += self.indentation+i+"\n"
            return r
        def resolv(self):
            global CODEREF_ERRORS
            r = []
            if self.name in CODE:
                for i in CODE[self.name]:
                    i.referenced = True
                    if not self.count in i.references:
                        i.references.append(self.count)
                    for j in i.resolv():
                        r.append(self.indentation+j)
            else:
                if not self.name in CODEREF_ERRORS:
                    CODEREF_ERRORS.append(self.name)
            return r

class Paragraph:
    def __init__(self):
        self.line = ""
        self.content = []
        self.type = "paragraph"
    def append(self, line):
        for i in line.split(" "):
            if i != "":
                self.line += u" "+i
        self.line = self.line.strip()
    def debugDisplay(self, deep):
        debugDisplay("par", deep)
        for i in self.content:
            i.debugDisplay(deep+1)
    def formatText(self, length, prefixed = False):
        r = u""
        for i in self.content:
            r += i.formatText(length)
        t2 = []
        l = u""
        split = []
        mode = "text"
        escape = False
        word = u""
        for i in r:
            if escape:
                word += i
                escape = False
            elif i == "\\":
                word += i
                escape = True
            elif mode == "link":
                word += i
                if i == "]":
                    mode = "text"
            elif mode == "code":
                word += i
                if i == ">":
                    mode = "text"
            elif i == "<":
                word += i
                mode = "code"
            elif i == "[":
                word += i
                mode = "link"
            elif i == " ":
                split.append(word)
                word = u""
            else:
                word += i
        split.append(word)

        for i in range(len(split)):
            if len(l)+len(split[i])+1 < length:
                if i < len(split)-2 and begin(split[i+1], "<code") and len(l)+len(split[i])+len(split[i+1])+3 > length:
                    t2.append(l)
                    l = split[i]+" "
                else:
                    l += split[i]+" "
            else:
                t2.append(l)
                l = split[i]+" "
        t2.append(l)
        r = u""
        for i in t2[:-1]:
            r += justify(i, length)+"\n"
        r += t2[-1]+"\n"
        if not prefixed:
            r = u"\n\n"+r
        return r
    def outputHTML(self, prefixed = False):
        r = u""
        for i in self.content:
            r += i.outputHTML()
        if not prefixed:
            r = u"<p>\n"+r+"</p>\n"
        return r
    def important(self):
        return len(self.line) > 0
    def parse(self):
        mode = [self.Text()]
        i = 0
        while i < len(self.line):
            c = self.line[i]
            if mode[-1].type == "escape":
                mode.pop()
                mode[-1].add(c)
            elif mode[-1].type in ["link", "anchor"]:
                if c == "]":
                    mode = self.parseChange(mode)
                    mode.append(self.Text())
                    mode = self.parseChange(mode)
                else:
                    mode[-1].add(c)
            elif c == "\\":
                mode.append(self.Escape())
            elif mode[-1].type == "code":
                if c == ">":
                    mode = self.parseChange(mode)
                    mode.append(self.Text())
                    mode = self.parseChange(mode)
                else:
                    mode[-1].add(c)
            elif self.line[i:i+2] == "//":
                if mode[-1].type != "italic":
                    mode.append(self.Italic())
                else:
                    mode = self.parseChange(mode)
                    mode.append(self.Text())
                    mode = self.parseChange(mode)
                i += 1
            elif self.line[i:i+2] == "__":
                if mode[-1].type != "underline":
                    mode.append(self.Underline())
                else:
                    mode = self.parseChange(mode)
                    mode.append(self.Text())
                    mode = self.parseChange(mode)
                i += 1
            elif self.line[i:i+2] == "--":
                if mode[-1].type != "overline":
                    mode.append(self.Overline())
                else:
                    mode = self.parseChange(mode)
                    mode.append(self.Text())
                    mode = self.parseChange(mode)
                i += 1
            elif self.line[i:i+2] == "**":
                if mode[-1].type != "bold":
                    mode.append(self.Bold())
                else:
                    mode = self.parseChange(mode)
                    mode.append(self.Text())
                    mode = self.parseChange(mode)
                i += 1
            elif c == "*":
                mode.append(self.NoteRef())
                mode = self.parseChange(mode)
            elif c == "[":
                if mode[-1].type == "text":
                    linktext = self.Text()
                    if i != 0 and self.line[i-1] != " ":
                        linktext.add(self.line[:i].split(" ")[-1])
                        mode[-1].content = mode[-1].content[:-len(linktext.content)]
                else:
                    linktext = mode.pop()
                if self.line[i:i+4] == "[..]":
                    mode.append(self.URLRef())
                    mode[-1].content = linktext
                    mode = self.parseChange(mode)
                    i += 3
                elif self.line[i+1] == "=":
                    mode.append(self.Anchor())
                    mode[-1].content = linktext
                    i += 1
                else:
                    mode.append(self.Link())
                    mode[-1].content = linktext
                text = ""
            elif c == "(":
                mode.append(self.Bracket())
            elif c == ")" and mode[-1].type == "bracket":
                if i < len(self.line)-1 and self.line[i+1] != "[":
                    mode = self.parseChange(mode)
                    mode.append(self.Text())
                    mode = self.parseChange(mode)
            elif c == "<":
                mode.append(self.Code())
                if self.line[i+1] == "<":
                    lang = self.line[i+2:].split(">")[0]
                    mode[-1].lang = lang
                    i += len(lang)+2
            else:
                mode[-1].add(c)
            i += 1
        self.parseChange(mode)

    def parseChange(self, mode):
        el = mode.pop()
        if len(mode) == 0:
            self.content.append(el)
            mode.append(self.Text())
        elif mode[-1].type == "text":
            el2 = mode.pop()
            if len(mode) > 0:
                mode[-1].append(el2)
                mode[-1].append(el)
            else:
                self.content.append(el2)
                self.content.append(el)
            mode.append(self.Text())
        else:
            mode[-1].append(el)
        return mode
        
    class Text:
        def __init__(self, content = u""):
            self.type = "text"
            self.content = content
        def add(self, el):
            self.content += el
        def debugDisplay(self, deep):
            debugDisplay("text", deep, self.content)
        def formatText(self, length):
            return escape(self.content)
        def outputHTML(self, inlink = None):
            return self.content

    class Bold:
        def __init__(self):
            self.type = "bold"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("bold", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = u""
            for i in self.content:
                r += i.formatText(length)
            return "**"+r+"**"
        def outputHTML(self, inlink = None):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "<span class=\"bold\">"+r+"</span>"

    class Italic:
        def __init__(self):
            self.type = "italic"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("italic", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = u""
            for i in self.content:
                r += i.formatText(length)
            return "//"+r+"//"
        def outputHTML(self, inlink = None):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "<span class=\"italic\">"+r+"</span>"

    class Underline:
        def __init__(self):
            self.type = "underline"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("underline", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = u""
            for i in self.content:
                r += i.formatText(length)
            return "__"+r+"__"
        def outputHTML(self, inlink = None):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "<span class=\"underline\">"+r+"</span>"

    class Overline:
        def __init__(self):
            self.type = "overline"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("overline", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = u""
            for i in self.content:
                r += i.formatText(length)
            return "--"+r+"--"
        def outputHTML(self, inlink = None):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            return "<span class=\"overline\">"+r+"</span>"

    class Bracket:
        def __init__(self):
            self.type = "bracket"
            self.content = [Paragraph.Text()]
        def append(self, el):
            self.content.append(el)
        def add(self, el):
            self.content[-1].add(el)
        def debugDisplay(self, deep):
            debugDisplay("bracket", deep)
            for i in self.content:
                i.debugDisplay(deep+1)
        def formatText(self, length):
            r = "("
            for i in self.content:
                r += i.formatText(length)
            r += ")"
            return r
        def outputHTML(self, inlink = False):
            r = u""
            for i in self.content:
                r += i.outputHTML()
            if not inlink:
                r = "("+r+")"
            return r

    class Code:
        def __init__(self):
            self.type = "code"
            self.content = u""
            self.lang = None
        def add(self, el):
            self.content += el
        def debugDisplay(self, deep):
            if self.lang == None:
                lang = "None"
            else:
                lang = self.lang
            debugDisplay("code", deep, u"("+lang+u")"+self.content)
        def formatText(self, length):
            if self.lang == None:
                lang = ""
            else:
                lang = "<"+self.lang+">"
            return "<"+lang+escape(self.content)+">"
        def outputHTML(self, inlink = None):
            global COLOR_ERRORS
            if self.lang == None:
                language = DOCUMENT_LANGUAGE
            else:
                language = self.lang
            try:
                lexer = get_lexer_by_name(language)
            except pygments.util.ClassNotFound:
                if not language in COLOR_ERRORS:
                    COLOR_ERRORS.append(language)
                lexer = get_lexer_by_name("text")
            formatter = HtmlFormatter(cssclass="source", nowrap = True)
            result = highlight(self.content, lexer, formatter).strip()
            return "<span class=\"textcode\">"+result+"</span>"

    class URLRef:
        def __init__(self):
            global URLREF
            self.type = "urlref"
            self.content = Paragraph.Text()
            self.ref = URLREF
            URLREF += 1
        def debugDisplay(self, deep):
            debugDisplay("urlref", deep)
            self.content.debugDisplay(deep+1)
        def formatText(self, length):
            return self.content.formatText(length)+"[..]"
        def outputHTML(self, inlink = None):
            global FOOTURL
            if self.ref == None:
                ref = "#"
            else:
                ref = FOOTURL[self.ref].url
            return "<a href=\""+ref+"\" target=\"about:blank\">"+self.content.outputHTML(True)+"</a>"

    class Link:
        def __init__(self):
            self.type = "link"
            self.name = ""
            self.content = Paragraph.Text()
        def add(self, el):
            self.name += el
        def debugDisplay(self, deep):
            debugDisplay("link", deep)
            self.content.debugDisplay(deep+1)
        def formatText(self, length):
            return self.content.formatText(length)+"["+self.name+"]"
        def outputHTML(self, inlink = None):
            return "<a href=\"#"+refEscape(self.name)+"\">"+self.content.outputHTML(True)+"</a>"

    class Anchor:
        def __init__(self):
            self.type = "anchor"
            self.name = ""
            self.content = Paragraph.Text()
        def add(self, el):
            self.name += el
        def debugDisplay(self, deep):
            debugDisplay("anchor", deep, "name: "+self.name)
            self.content.debugDisplay(deep+1)
        def formatText(self, length):
            return self.content.formatText(length)+"[="+self.name+"]"
        def outputHTML(self, inlink = None):
            return "<a id=\""+refEscape(self.name)+"\">"+self.content.outputHTML()+"</a>"

    class NoteRef:
        def __init__(self):
            global NOTEREF
            self.type = "noteref"
            NOTEREF += 1
            self.ref = NOTEREF
        def debugDisplay(self, deep):
            debugDisplay("noteref", deep)
        def formatText(self, length):
            return "*"
        def outputHTML(self, inlink = None):
            if self.ref != None:
                ref = self.ref
            else:
                ref = "0"
            return "<a href=\"#ref"+str(ref)+"\" id=\"toref"+str(ref)+"\"><sup>"+str(ref)+"</sup></a>"

    class Escape:
        def __init__(self):
            self.type = "escape"

class OrderedList:
    def __init__(self, line):
        self.content = [line]
        self.pars = []
        self.type = "ordered list"
    def append(self, line):
        self.content.append(line.strip())
    def debugDisplay(self, deep):
        debugDisplay("ol", deep)
        for i in self.pars:
            i.debugDisplay(deep+1)
    def important(self):
        return len(self.content) > 0
    def parse(self):
        for line in self.content:
            line = line.strip()
            if begin(line, "#"):
                self.pars.append(Documentation())
            if begin(line, "#") or begin(line, "'"):
                line = line[1:]
            self.pars[-1].append(line)
        for i in self.pars:
            i.parse()
    def formatText(self, length, prefixed = None):
        r = u""
        for par in self.pars:
            par = par.formatText(length-3).strip().split("\n")
            if par[0] != "" and par[0][0] == " ":
                par[0] = par[0][1:] 
            r += " # "+par[0]+"\n"
            for i in par[1:]:
                if i != "" and i[0] == " ":
                    i = i[1:]
                r += " ' "+i+"\n"
        return r+"\n"
    def outputHTML(self, prefixed = None):
        r = u"<ol>"
        for par in self.pars:
            r += "<li>"+par.outputHTML()+"</li>"
        return r+"</ol>\n"

class UnorderedList:
    def __init__(self, line):
        self.content = [line]
        self.pars = []
        self.type = "unordered list"
    def append(self, line):
        self.content.append(line.strip())
    def debugDisplay(self, deep):
        debugDisplay("ul", deep)
        for i in self.pars:
            i.debugDisplay(deep+1)
    def important(self):
        return len(self.content) > 0
    def parse(self):
        for line in self.content:
            line = line.strip()
            if begin(line, "-"):
                self.pars.append(Documentation())
            if begin(line, "-") or begin(line, "'"):
                line = line[1:]
            self.pars[-1].append(line)
        for i in self.pars:
            i.parse()
    def formatText(self, length, prefixed = None):
        r = u""
        for par in self.pars:
            par = par.formatText(length-3).strip().split("\n")
            if par[0] != "" and par[0][0] == " ":
                par[0] = par[0][1:] 
            r += " - "+par[0]+"\n"
            for i in par[1:]:
                if i != "" and i[0] == " ":
                    i = i[1:]
                r += " ' "+i+"\n"
        return r+"\n"
    def outputHTML(self, prefixed = None):
        r = u"<ul>"
        for par in self.pars:
            r += "<li>"+par.outputHTML()+"</li>"
        return r+"</ul>\n"

class FootNote:
    def __init__(self, line):
        global FOOTNOTE
        self.content = [line]
        self.pars = Documentation()
        FOOTNOTE.append(self)
        self.count = len(FOOTNOTE)
        self.type = "footnote"
    def append(self, line):
        self.content.append(line)
    def debugDisplay(self, deep):
        debugDisplay("footnote", deep)
        self.pars.debugDisplay(deep+1)
    def important(self):
        return len(self.content) > 0
    def parse(self):
        for i in self.content:
            if begin(i, "*:"):
                i = i[2:].strip()
            self.pars.append(i)
        self.pars.parse()
    def formatText(self, length, prefixed = None):
        pars = self.pars.formatText(length-4, True).split("\n")
        r = "*: "+pars[0]+"\n"
        for i in pars[1:]:
            r += "    " +i+"\n"
        return " "+r.strip()+"\n"
    def outputHTML(self, prefixed = None):
        r = u"<p>\n<a href=\"#toref"+str(self.count)+"\" id=\"ref"+str(self.count)+"\">^ "+str(self.count)+":</a> "
        r += self.pars.outputHTML(True)
        return r+"<p>\n"


class FootURL:
    def __init__(self, line):
        global FOOTURL
        self.url = line[3:].strip()
        FOOTURL.append(self)
        self.type = "footurl"
    def append(self, line):
        self.url += line.strip()
    def debugDisplay(self, deep):
        debugDisplay("footurl", deep, self.url)
    def important(self):
        return len(self.url) > 0
    def parse(self):
        pass
    def formatText(self, length, prefixed = None):
        r = u"..: "
        count = 0
        for c in self.url:
            count += 1
            r += c
            if count == length-4:
                r += "\n    "
                count = 0
        return r+"\n"
    def outputHTML(self, prefixed = None):
        return ""

class Warn:
    def __init__(self, line):
        self.content = [line]
        self.pars = Documentation()
        self.type = "warn"
    def append(self, line):
        self.content.append(line)
    def debugDisplay(self, deep):
        debugDisplay("important", deep)
        self.pars.debugDisplay(deep+1)
    def important(self):
        for line in self.content:
            if line[:3] == "/!\\":
                line = line[3:]
            if line.strip() != "":
                return True
        return False
    def parse(self):
        for line in self.content:
            if line[:3] == "/!\\":
                line = line[3:].strip()
            if line[-3:] == "/!\\":
                line = line[:-3].strip()
            self.pars.append(line)
        self.pars.parse()
    def formatText(self, length, prefixed = None):
        lines = self.pars.formatText(length - MARGINS*2 - 8).strip().split("\n")
        r = u""
        if not prefixed:
            r += u"\n"
        for i in lines:
            r += INDENT + "/!\\ "+i.ljust(length - MARGINS*2 - 8)+" /!\\\n"
        return r
    def outputHTML(self, prefixed = None):
        r = "<div class=\"warning\">"+self.pars.outputHTML()+"</div>"
        return r

class Image:
    def __init__(self, line):
        self.name = line
        self.type = "image"
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("image", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[6:].strip()
    def formatText(self, length, prefixed = None):
        return "~Image "+self.name+"\n"
    def outputHTML(self, prefixed = None):
        try:
            img = open(self.name).read()
            img = base64.b64encode(img)
            name = path.basename(self.name)
            return "<div class=\"img\"><img src=\"data:image/*;base64,"+img+"\" alt=\""+name+"\"></div>"
        except IOError:
            sys.stderr.write(u"Fichier non trouvé :"+self.name+"\n")
            return "<div>Image not found</div>"

class Remain:
    def __init__(self, line):
        global REFCOUNT
        self.name = line
        self.type = "remain"
        REFCOUNT += 1
        self.count = REFCOUNT
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("remain", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[7:].strip()
        if not self.count in CODE[self.name][0].references:
            CODE[self.name][0].references.append(self.count)
    def formatText(self, length, prefixed = None):
        return "~Remain "+self.name+"\n"
    def outputHTML(self, prefixed = None):
        r = u"<div class=\"codechunk\"><div class=\"codehead\">Rappel du code <a href=\"#"+refEscape(self.name)+"1\" id=\"coderef"+str(self.count)+"\">"+self.name+"</a> :</div>"
        line = 1
        for i in CODE[self.name]:
            r += i.outputHTML(True, line)
            line += len(i.resolved)
        r += "</div>\n"
        return r

class Copy:
    def __init__(self, line):
        self.name = line
        self.file1 = ""
        self.file2 = ""
        self.type = "copy"
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("copy", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[5:].strip()
    def formatText(self, length, prefixed = None):
        return "~Copy "+self.name+"\n"
    def outputHTML(self, prefixed = None):
        return ""

class Display:
    def __init__(self, line):
        global REFCOUNT
        self.name = line
        self.type = "display"
        REFCOUNT += 1
        self.count = REFCOUNT
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("display", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[8:].strip()
        if not self.count in CODE[self.name][0].references:
            CODE[self.name][0].references.append(self.count)
    def formatText(self, length, prefixed = None):
        return "~Display "+self.name+"\n"
    def outputHTML(self, prefixed = None):
        global COLOR_ERRORS
        r = u"<div class=\"codechunk\"><div class=\"codehead\">Sortie du code <a href=\"#"+refEscape(self.name)+"1\" id=\"coderef"+str(self.count)+"\">"+self.name+"</a> :</div>"
        if CODE[self.name][0].language == None:
            format_language = DOCUMENT_LANGUAGE
        else:
            format_language = CODE[self.name][0].language
        code = ""
        for i in CODE[self.name]:
            for j in i.resolved:
                code += j+"\n"
        try:
            lexer = get_lexer_by_name(format_language)
        except pygments.util.ClassNotFound:
            if not format_language in COLOR_ERRORS:
                COLOR_ERRORS.append(format_language)
            lexer = get_lexer_by_name("text")
        formatter = HtmlFormatter(linenos=True, cssclass="source")
        r += highlight(code, lexer, formatter)
        r += "</div>\n"
        return r

class Get:
    def __init__(self, line):
        self.name = line
        self.type = "get"
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("get", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[4:].strip()
    def formatText(self, length, prefixed = None):
        return "~Get "+self.name+"\n"
    def outputHTML(self, prefixed = None):
        return ""

class Include:
    def __init__(self, line):
        self.name = line
        self.type = "include"
    def debugDisplay(self, deep):
        i = self.name
        debugDisplay("include", deep, i)
    def important(self):
        return len(self.name) > 0
    def parse(self):
        self.name = self.name[8:].strip()
    def formatText(self, length, prefixed = None):
        return "~Include "+self.name+"\n"
    def outputHTML(self, prefixed = None):
        try:
            return "<pre>"+codecs.open(self.name, 'r', encoding = "utf-8").read()+"</pre>"
        except IOError:
            sys.stderr.write(u"Fichier non trouvé : "+self.name+"\n")
            return "<pre>File not found</pre>"

class TextBlock:
    def __init__(self):
        self.raw_content = []
        self.content = []
    def append(self, line):
        if line.strip() != "":
            self.raw_content.append(line.strip())
    def debugDisplay(self, deep):
        for i in self.raw_content:
            debugDisplay("block", deep, i)
    def important(self):
        return len(self.raw_content) > 0
    def parse(self):
        """ Renvoie une liste de paragraphes et d'autres éléments (liste…) """
        mode = "par"
        element = Paragraph()
        block = []
        for line in self.raw_content:
            line = line.strip()
            if begin(line, "*:"):
                mode = "footnote"
                if element.important():
                    block.append(element)
                element = FootNote(line)
            elif begin(line, "..:"):
                mode = "footurl"
                if element.important():
                    block.append(element)
                element = FootURL(line)
            elif begin(line, "'") and mode == "unordered list":
                element.append(line)
            elif begin(line, "-") and mode == "unordered list":
                element.append("")
                element.append(line)
            elif begin(line, "-") and (not begin(line, "--")) and mode != "unordered list":
                mode = "unordered list"
                if element.important():
                    block.append(element)
                element = UnorderedList(line)
            elif begin(line, "'") and mode == "ordered list":
                element.append(line)
            elif begin(line, "#") and mode == "ordered list":
                element.append("")
                element.append(line)
            elif begin(line, "#") and mode != "ordered list":
                mode = "ordered list"
                if element.important():
                    block.append(element)
                element = OrderedList(line)
            elif begin(line, "~image"):
                mode = "image"
                if element.important():
                    block.append(element)
                block.append(Image(line))
                element = Paragraph()
            elif begin(line, "~get"):
                mode = "get"
                if element.important():
                    block.append(element)
                block.append(Get(line))
                element = Paragraph()
            elif begin(line, "~include"):
                mode = "include"
                if element.important():
                    block.append(element)
                block.append(Include(line))
                element = Paragraph()
            elif begin(line, "~copy"):
                mode = "copy"
                if element.important():
                    block.append(element)
                block.append(Copy(line))
                element = Paragraph()
            elif begin(line, "~remain"):
                mode = "remain"
                if element.important():
                    block.append(element)
                block.append(Remain(line))
                element = Paragraph()
            elif begin(line, "~display"):
                mode = "display"
                if element.important():
                    block.append(element)
                block.append(Display(line))
                element = Paragraph()
            elif begin(line, "/!\\") and mode != "warn":
                mode = "warn"
                if element.important():
                    block.append(element)
                element = Warn(line)
            elif mode in ["image", "get", "include", "remain", "display", "copy", "ordered list", "unordered list"]:
                mode = "par"
                if element.important():
                    block.append(element)
                element = Paragraph()
                element.append(line)
            else:
                element.append(line)
        if element.important():
            block.append(element)
        for element in block:
            element.parse()
        return block

class Documentation:
    def __init__(self):
        self.lines = []
        self.pars = []
        self.blocks = []
        self.type = "documentation"

    def append(self, line):
        self.lines.append(line.strip())

    def important(self):
        """ Renvoie False si la documentation ne contient que des lignes vides """
        for i in self.lines:
            if i != "":
                return True
        return False

    def parse(self):
        block = TextBlock()
        for i in self.lines:
            if i != "":
                block.append(i)
            else:
                if block.important():
                    self.blocks.append(block)
                block = TextBlock()
        if block.important():
            self.blocks.append(block)
        for i in self.blocks:
            self.pars += i.parse()

    def debugDisplay(self, deep):
        debugDisplay("docu", deep)
        for i in self.pars:
            i.debugDisplay(deep+1)
    def formatText(self, length, prefixed = False):
        r = u""
        for i in self.pars:
            r += i.formatText(length, prefixed)
        text = u""
        old = None
        for i in r.split("\n"):
            if not (old == "" and i.strip() == ""):
                text += i+"\n"
            old = i.strip()
        return text
    def outputHTML(self, prefixed = False):
        r = u""
        for i in self.pars:
            if i.type != "footnote":
                r += i.outputHTML(prefixed)
        return r


class Title:
    def __init__(self):
        self.name = []
    def important(self):
        """ Renvoie True si le titre n'est pas vide. """
        for i in self.name:
            if i != "":
                return True
        return False
    def append(self, c):
        self.name.append(c.strip())
    def debugDisplay(self, deep):
        for i in self.name:
            debugDisplay("title", deep, i)
    def formatText(self, line_length):
        max_width = 0
        for i in self.name:
            max_width = max(max_width, len(i))
        max_width += 2
        bar = ""
        for i in range(max_width+2):
            bar += "*"
        r = u""
        r += bar.center(line_length)+"\n"
        for i in self.name:
            text = u"*"+i.center(max_width)+u"*"
            r += text.center(line_length)+"\n"
        r += bar.center(line_length)+"\n"
        return r
    def outputHTMLTitle(self):
        r = u"<title> | "
        for i in self.name:
            r += i+u" | "
        r += "</title>\n"
        return r
    def outputHTML(self):
        r = u"<header>\n"
        for i in self.name:
            r += "\t<div>"+i+"</div>\n"
        r += "</header>\n"
        return r

class Introduction:
    def __init__(self):
        self.raw_content = []
        self.content = []
    def append(self, line):
        self.raw_content.append(line)
    def important(self):
        for i in self.content:
            if i != "":
                return True
        return False
    def split(self):
        last_chunk = Documentation()
        mode = "documentation"
        for line in self.raw_content:
            sline = line.strip()
            if begin(line, "<code"):
                mode = "begincode"
                if last_chunk.important():
                    self.content.append(last_chunk)
                last_chunk = Code(line)
            elif mode in ["code", "begincode"]:
                if line.rstrip() == ">":
                    mode = "endcode"
                else:
                    mode = "code"
                    last_chunk.append(line)
            elif mode == "endcode":
                mode = "documentation"
                if last_chunk.important():
                    self.content.append(last_chunk)
                last_chunk = Documentation()
            else:
                last_chunk.append(line.strip())
        if last_chunk.important():
            self.content.append(last_chunk)
    def debugDisplay(self, deep):
        debugDisplay("intro", deep)
        for i in self.content:
            i.debugDisplay(deep+1)
    def parse(self):
        for i in self.content:
            i.parse()
    def formatText(self, length):
        r = u""
        for i in self.content:
            r += i.formatText(length)
        return r
    def outputHTML(self):
        r = u""
        for i in self.content:
            r += i.outputHTML()
        return r
    def resolv(self):
        for i in self.content:
            if i.type == "code":
                i.resolv()

class Authors:
    def __init__(self):
        self.names = []
    def important(self):
        return len(self.names) > 0
    def debugDisplay(self, deep):
        for i in self.names:
            debugDisplay("authors", deep, i)
    def append(self, name):
        if name.strip() != "":
            self.names.append(name)
    def formatText(self, length):
        r = u""
        for i in self.names:
            r += u"~Authors "+i+u"\n"
        return r
    def outputHTML(self):
        r = "<div class=\"authors\">Par "
        for i in self.names:
            r += "<span>"+i+"</span>"
        return r+"</div>"
    def outputHTMLMeta(self):
        r = "<meta name=\"author\" content=\""
        for i in self.names:
            r += i+", "
        return r[:-2]+"\">\n"


class Document:
    def __init__(self, name = None):
        """ Crée un document et charge le fichier si passé en paramètre. """
        self.type = "section"
        self.parent = None
        self.name = name
        self.position = 0
        self.sections = []
        self.introduction = Introduction()
        self.title = Title()
        self.authors = Authors()
        self.abstract = None
        self.license = None
        self.code_type = None
        self.lines = []
        self.original_depth = 0

    def fromFile(self, file_name):
        """ Récupère le code source d'un fichier (interprète ~Get) et remplace
        les chemins de fichiers par leur chemin absolu. """
        global CODE, FOOTNOTE, URLREF, NOTEREF, FOOTURL, REFCOUNT, CODEREF_ERRORS
        self.type = "document"
        filename = path.abspath(file_name)
        basedir = path.dirname(filename)
        f = codecs.open(filename, 'r', encoding="utf-8")
        lines = f.readlines()
        d = Document()
        d.fromOneFile(filename)
        d.parse()
        FOOTNOTE = []
        NOTEREF = 0 
        URLREF = 0
        FOOTURL = []
        CODE = {}
        CODEREF_ERRORS = []
        REFCOUNT = 0
        infile = codecs.open(filename, encoding="utf-8").read()
        outfile = d.formatText()
        if infile != outfile:
            codecs.open(filename+".clean", "w", encoding="utf-8").write(outfile)
        f.close()
        for i in lines:
            if begin(i, "~get"):
                filename = i.strip()[4:].strip()
                if filename != "":
                    try:
                        document = Document()
                        document.fromFile(path.join(basedir, filename))
                        self.lines += document.lines
                    except IOError:
                        sys.stderr.write(u"Fichier non trouvé : "+filename+"\n")
                        self.lines.append(i)
            else:
                if begin(i, "~include"):
                    i = "~include "+path.join(basedir, i[8:].strip())
                if begin(i, "~image"):
                    i = "~image "+path.join(basedir, i[6:].strip())
                if begin(i, "~copy"):
                    files = splitPath(i[5:].strip())
                    fromFile = path.join(basedir, files[0])
                    toFile = path.join(os.getcwd(), "src", files[1])
                    if not path.exists(path.dirname(toFile)):
                        os.makedirs(path.dirname(toFile))
                    open(toFile, "w").write(open(fromFile).read())
                self.lines.append(i)

    def fromOneFile(self, filename):
        """ Récupère le code source d'un fichier (sans interpreter ~Get) """
        filename = path.abspath(filename)
        basedir = path.dirname(filename)
        try:
            f = codecs.open(filename, 'r', encoding="utf-8")
            lines = f.readlines()
            f.close()
        except IOError:
            sys.stderr.write(u"Fichier non trouvé : "+filename+"\n")
            lines = []
        for i in lines:
            self.lines.append(i)

    def parseStructure(self, level = 0):
        """ Place les lignes dans la structure du document. """
        global DOCUMENT_LANGUAGE
        mode = "intro"
        introduction = True
        abstract = []
        document = Document()
        document.parent = self
        position = 1
        for line in self.lines:
            sline = line.strip()
            if begin(line, "<code"):
                mode = "begincode"
            elif mode in ["code", "begincode"]:
                if line.rstrip() == ">":
                    mode = "endcode"
                else:
                    mode = "code"
            elif begin(sline, "==") and not introduction:
                mode = "sectionpar"
                line = sline[1:]
            elif begin(sline, "="):
                mode = "section"
                original_depth = 0
                while sline[0] == "=":
                    original_depth += 1
                    sline = sline[1:]
                line = sline.strip()
                if not introduction:
                    document.parseStructure(level+1)
                introduction = False
                if document.important():
                    self.sections.append(document)
                    position = document.position+1
                document = Document(line)
                document.original_depth = original_depth -  1
                document.parent = self
                document.position = position
            elif introduction:
                if detect_starline(sline):
                    if mode in ["title", "begintitle"]:
                        mode = "endtitle"
                    else:
                        mode = "begintitle"
                elif mode in ["begintitle", "title"]:
                    mode = "title"
                    if len(sline) > 0 and sline[0] == "*":
                        sline = sline[1:]
                    if len(sline) > 2 and sline[-1] == "*":
                        sline = sline[:-1]
                    line = sline.strip()
                    self.title.append(line)
                elif begin(sline, "~authors"):
                    mode = "authors"
                    line = sline[8:].strip()
                    self.authors.append(line)
                elif begin(sline, "~code"):
                    mode = "code type"
                    line = sline[5:].strip()
                    self.code_type = line
                    DOCUMENT_LANGUAGE = line
                elif sline.lower() == "~abstract~":
                    mode = "beginabstract"
                    self.abstract = Document()
                    self.abstract.type = "abstract"
                elif mode in ["beginabstract", "abstract"]:
                    mode = "abstract"
                    if sline == "~~~":
                        mode = "endabstract"
                        self.abstract.parseStructure(level+1)
                    else:
                        self.abstract.lines.append(line)
                elif mode in ["endabstract", "endlicense"]:
                    if introduction:
                        mode = "intro"
                    else:
                        mode = "sectionpar"
                elif sline.lower() == "~license~":
                    mode = "beginlicense"
                    self.license = Document()
                    self.license.type = "license"
                elif mode in ["beginlicense", "license"]:
                    mode = "license"
                    if sline == "~~~":
                        mode = "endlicense"
                        self.license.parseStructure(level+1)
                    else:
                        self.license.lines.append(line)
            else:
                mode = "sectionpar"
            if mode in ["intro", "sectionpar", "begincode", "coderef", "endcode", "code"]:
                if introduction:
                    self.introduction.append(line)
                else:
                    document.lines.append(line)
        if not introduction:
            document.parseStructure(level+1)
        if document.important():
            self.sections.append(document)

    def getPosition(self):
        """ Renvoie un tableau contenant le chemin d'accès à cette partie du
        document, en terme de sections. """
        position = [self.position]
        parent = self.parent
        while parent != None:
            position = [parent.position]+position
            parent = parent.parent
        return position

    def debugDisplay(self, deep = 0):
        """ Affiche la structure du document """
        debugDisplay("document", deep)
        if self.title.important():
            self.title.debugDisplay(deep)
        if self.name != None:
            t = ""
            position = []
            for i in self.getPosition()[1:]:
                position.append(str(i))
            debugDisplay("secname", deep, ".".join(position)+" "+self.name)
        if self.authors.important():
            self.authors.debugDisplay(deep)
        if self.code_type != None:
            debugDisplay("set code", deep, self.code_type)
        if self.abstract != None:
            self.abstract.debugDisplay(deep)
        if self.introduction.important():
            self.introduction.debugDisplay(deep)
        for section in self.sections:
            section.debugDisplay(deep+1)

    def splitDocCode(self):
        """ Place le code et la documentation de l'introduction dans une suite
        de morceaux séparés (un morceau de code, un morceau de doc, et ainsi de
        suite), et effectue la même séparation sur les sections qui la suivent.
        """
        self.introduction.split()
        if self.abstract != None:
            self.abstract.splitDocCode()
        if self.license != None:
            self.license.splitDocCode()
        for section in self.sections:
            section.splitDocCode()
    def parseChunks(self):
        """ Découpe les paragraphes et prépare leur mise en forme. """
        self.introduction.parse()
        if self.abstract != None:
            self.abstract.parseChunks()
        if self.license != None:
            self.license.parseChunks()
        for section in self.sections:
            section.parseChunks()
    def important(self):
        if self.name != "" and self.name != None:
            return True
        for i in self.sections:
            if i.important:
                return True
        if self.introduction.important():
            return True
        if self.title.important():
            return True
        if self.authors.important():
            return True
        if self.abstract != None and self.abstract.important():
            return True
        if self.license != None and self.license.important():
            return True
        if self.code_type != None and self.code_type.important():
            return True
        return False
    def parse(self):
        """ Analyse le document. """
        self.parseStructure()
        self.splitDocCode()
        self.parseChunks()
        #self.resolveReferences()
    def formatText(self, line_length = DEFAULT_LENGTH):
        r = u""
        if self.title.important():
            r += "\n"
            r += self.title.formatText(line_length)
            r += "\n"
        if self.name != None:
            r += "\n"
            for i in self.getPosition()[1:]:
                r += "="
            for i in range(self.original_depth):
                r += "="
            r += " "+self.name
            r += "\n"
        r += "\n"
        if self.authors.important():
            r += self.authors.formatText(line_length)
        if self.code_type != None:
            r += u"~Code "+self.code_type+"\n"
        r += "\n"
        if self.abstract != None:
            r += "\n"
            r += "\n"+u"~Abstract~".center(line_length)+"\n\n"
            for i in self.abstract.formatText(line_length-MARGINS*2).split("\n"):
                r += INDENT + i + "\n"
            r += "\n"+u"~~~".center(line_length)+"\n\n"
        if self.introduction.important():
            r += "\n"
            r += self.introduction.formatText(line_length)
            r += "\n"
        for section in self.sections:
            r += "\n"
            r += section.formatText(line_length)+"\n\n"
        if self.license != None:
            r += "\n"
            r += "\n"+u"~License~".center(line_length)+"\n\n"
            for i in self.license.formatText(line_length-MARGINS*2).split("\n"):
                r += INDENT + i + "\n"
            r += "\n"+u"~~~".center(line_length)+"\n\n"
        # On remplace les doubles lignes vides par des lignes vides uniques
        mode = "doc"
        text = u""
        old = ""
        for i in r.split("\n"):
            if mode == "code":
                text += i+"\n"
                if i != "" and i[0] == ">":
                    mode = "doc"
                    text += "\n"
                    old = ""
            else:
                if not (old == "" and i.strip() == ""):
                    if begin(i, "<code"):
                        mode = "code"
                    text += i+"\n"
                old = i.strip()
        return text
    def outputHTML(self, top = True, ebook = False):
        r = u""
        if top:
            r += u"""<!doctype html>
                     <head>
                     <meta charset=\"utf-8\">
                     <style>
                        body {
                            text-align: justify;
                  """
            if not ebook:
                r += u"""
                            position: absolute;
                            width: 70%;
                            left: 15%;
                            top: 20px;
                            padding-bottom: 100px;
                      """
            r += u"""
                        }
                        h1 {
                            font-size: 2.0em;
                        }
                        h2 {
                            font-size: 1.8em;
                        }
                        h3 {
                            font-size: 1.6em;
                        }
                        h4 {
                            font-size: 1.4em;
                        }
                        h5 {
                            font-size: 1.2em;
                        }
                        h6 {
                            font-size: 1.0em;
                        }
                        sup {
                            font-size: 0.7em;
                        }
                        header {
                            border: 2px solid black;
                            padding: 40px;
                            margin-bottom: 40px;
                        }
                        header div {
                            text-align: center;
                            font-size: 3.0em;
                        }
                        .authors {
                            font-style: italic;
                            text-align: center;
                            margin: 5px;
                        }
                        .codetype {
                            color: #888;
                            text-align: center;
                            margin: 5px;
                        }
                        .abstract {
                        """
            if not ebook:
                r += u"""
                            width: 90%;
                            position: relative;
                            left: 5%;
                      """
            r += u"""
                            margin-top: 40px;
                            margin-bottom: 40px;
                        }
                        .abstract h1 {
                            text-align: center;
                        }
                        .license {
                        """
            if not ebook:
                r += u"""
                            width: 90%;
                            position: relative;
                            left: 5%;
                      """
            r += u"""
                            margin-top: 40px;
                            margin-bottom: 40px;
                        }
                        .license h1 {
                            text-align: center;
                        }
                        .warning {
                            border: 2px solid #88f;
                            padding: 5px;
                            padding-left: 20px;
                            padding-right: 20px;
                            border-radius: 10px 10px;
                            background-color: #ddf;
                            margin-bottom: 10px;
                        }
                        .bold {
                            font-weight: bold;
                        }
                        .italic {
                            font-style: italic;
                        }
                        .underline {
                            text-decoration: underline;
                        }
                        .overline {
                            text-decoration: line-through;
                        }
                        .img {
                            text-align: center;
                        }
                        .toc {
                  """
            if not ebook:
                r += u"""
                            width: 70%;
                            position: relative;
                            left: 15%;
                     """
            r += u"""
                            padding: 20px;
                            border: 2px solid black;
                            border-radius: 2px;
                            margin-bottom: 40px;
                        }
                        .toc h1 {
                            text-align: center;
                        }
                        pre {
                            margin: 0px;
                        }
                        .codechunk {
                            border: 1px solid #ffa;
                            border-radius: 10px;
                            background-color: #ffb;
                            margin: 10px;
                            padding: 10px;
                        }
                        .codehead {
                            background-color: #fda;
                            padding: 3px;
                        }
                        .textcode {
                            font-family: monospace;
                        }
                        li p {
                            margin: 0px;
                        }
                     """+ HtmlFormatter().get_style_defs() +"""
                     </style>
                     """
            if self.title.important():
                r += self.title.outputHTMLTitle()+"\n"
            if self.authors.important():
                r += self.authors.outputHTMLMeta()
            r += u"</head><body>\n"
        if self.title.important():
            r += self.title.outputHTML()+"\n"
        if self.name != None:
            r += "\n"
            p = self.getPosition()[1:]
            r += "<h"+str(len(p))+"><a id=\"sec"+refEscape(self.name)+"\">"
            for i in p:
                r += str(i)+"."
            r += " "+self.name
            r += "</a></h"+str(len(p))+">"
            r += "\n"
        r += "\n"
        if self.authors.important():
            r += self.authors.outputHTML()
        if self.code_type != None:
            r += u"<div class=\"codetype\">Projet codé majoritairement en "+self.code_type+"</div>\n"
        r += "\n"
        if self.abstract != None:
            r += "\n<div class=\"abstract\">"
            r += "\n"+u"<h1>Résumé</h1>"+"\n\n"
            r += self.abstract.outputHTML(False)
            r += "</div>"
        if top:
            r += u"<div class=\"toc\"><h1>Table des matières</h1>\n"
            r += self.outputHTMLToc()
            r += "</div>"
        if self.introduction.important():
            r += "\n"
            r += self.introduction.outputHTML()
            r += "\n"
        for section in self.sections:
            r += "\n"
            r += section.outputHTML(False)+"\n\n"
        if self.license != None:
            r += "\n<div class=\"license\">"
            r += "\n"+u"<h1>Licence</h1>"+"\n\n"
            r += self.license.outputHTML(False)
            r += "</div>"
        if top:
            r += "<hr>"
            for i in FOOTNOTE:
                r += i.outputHTML()
            r += "</body></html>"
        return r
    def outputHTMLToc(self):
        r = u""
        r += "<ol>\n"
        for i in self.sections:
            if i.name != None:
                r += "<li>"
                r += "<a href=\"#sec"+refEscape(i.name)+"\">"+i.name+"</a>\n"
                r += i.outputHTMLToc()
                r += "</li>"
        r += "</ol>\n"
        return r
    def resolv(self):
        if self.abstract != None:
            self.abstract.resolv()
        if self.introduction.important():
            self.introduction.resolv()
        for section in self.sections:
            section.resolv()
    def extractCode(self):
        global CODE
        srcdir = path.join(os.getcwd(), "src")
        for i in CODE:
            if not CODE[i][0].referenced:
                filename = path.join(srcdir, i)
                if not path.exists(path.dirname(filename)):
                    os.makedirs(path.dirname(filename))
                codecs.open(filename, "w", encoding="utf-8").write(CODE[i][0].outputCode())

d = Document()
filename = sys.argv[1]
project = path.basename(filename)
d.fromFile(filename)
d.parse()
d.resolv()
d.extractCode()
codecs.open(path.join(os.getcwd(), project+".html"), "w", encoding="utf-8").write(d.outputHTML())
codecs.open(path.join(os.getcwd(), project+"_epub_ready.html"), "w", encoding="utf-8").write(d.outputHTML(ebook = True))
for i in COLOR_ERRORS:
    sys.stderr.write("Pas de coloration syntaxique pour le langage "+i+"\n")
for i in CODEREF_ERRORS:
    sys.stderr.write("<Code: "+i+" n'existe pas.\n")
#d.debugDisplay()

