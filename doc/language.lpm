[=LPM format description] 

= The LPM markup language

== Syntax Basics

There are many types  of  tags  in  the  LPM language. Lightweight tags,
meant to  format  the  text,  commands,  that  will  execute  actions at
document  generation,  and  block  tags,  enabling  us  to  define  text
blocks. 

=== Blocks

The most basic mean to define a  block  is to left a blank line beetween
to text blocks: 

<Code (lpm): 
Here is a text block.

And a second text block,
spanning two lines.

And a third text block.
>

We  call  those  text  blocks  “paragraphs”.   When  the  file  will  be
formatted, the blocks lines will  be  merged  if  the  result is not too
long.* Thus, the example above will become, after formatting: 

<Code (lpm): 
Here is a text block.

And a second text block, spanning two lines.

And a third text block.
>

The second block is now one single  line.  In contrast, if a line is too
long, a line feed will be added. 

There are other means to define  blocs.  When  we create a list, or when
we insert  a  code  block,  we  create  blocks,  and  their  behavior is
different from the paragraphs one. 
 *: The source file of  the  documentation  is  formatted  to  fit in 72
    columns (72  characters  max  in  a  line).  The  paragraph  text is
    justified. Code blocks are not changed,  even  if they do not fit in
    72 characters.

=== Commands

Commands fit on one line. They  force  the  end  of a paragraph, even if
there is no blank line  beetween  them  and said paragraph. They usually
begin with the character <<lpm>\~>*. A  command  can enable us to define
a document  data  (source  code  language,  authors...),  or  to include
other files at this point of the text. Here is an example of commands: 

<Code (lpm): 
~code python

This is a pararaph
~include test.txt
>

In  that  example,  the  paragraph  doesn't  merge  with  the  following
command, even if the line is not  too  long. That is: **a command stay a
command, alone on a line**. 
 *: But not always. Commands  about  references  usually  begin with the
    same symbole as the one used to refer to them.

=== Lightweight Tags

Lightweight tags are tags found inside  lines.  There can be many on one
line. Lightweight tags act  inside  a  paragraph.  The  can  put text in
bold, italic, define  links...  And  all  of  that without deteriorating
the text with a characters overflow. Here is an example: 

<Code (lpm): 
This is a **bold text** followed by a reference to a footnote.*
>

=== The Simple Form, and the Complete Form of the language

The markup language's goal  is  to  make  the  source  documents easy to
read. To this  end,  characters  are  used  to  “draw” text decorations.
That way is aesthetic, but not nice  to  write  on our own. So, for some
markup, there is  an  abbreviated  form,  said  “simple”,  that  will be
transformed into the “complete”  form  by  our  program, more pretty. As
an example, we write the book title like that (simple form): 

<Code (lpm): 
**
* A title
**
>

Or, on a more heavy fashion: 

<Code (lpm): 
***********
* A title *
***********
>

And the software will center the title, thus giving us: 

<Code (lpm): 
                             ***********
                             * A title *
                             ***********
>

Those three means of writing a  title  are absolutely equivalent for our
tool, and are only there to make our life easier. 

== Document Structure

A document  as  a  title,  one  or  many  authors,  a  license,  and  an
abstract. In addition to that,  it  is  composed  of many sections, that
structure the document. 

=== The Title

The title is the title of  the  document  (tautology?).  It has to be at
the beginning of the said document.  It  is  written in a star frame. If
it is several lines long, the frame  is  as wide as the widest line, and
other lines are centered. 

<Code (lpm): 
               *****************************************
               *            Document Title             *
               *                                       *
               * This is a test document, with a title *
               *                                       *
               *****************************************
>

It is possible to simplify the  title,  at redaction time, by marking it
as follow: 
 - A line containing  at  least  two  stars,  and  nothing  else (except
 ' maybe  some  spaces  before  and  after  the  line),  will  mark  the
 ' beginning of the title.
 - After that, all lines begin  with  a  star,  then  the text. The last
 ' star of the line is ignored (as  it  is  considered to be part of the
 ' frame). If you want a line  ending  with  a  star (in addition to the
 ' one of the frame), you will have to put two stars.
 - After all these lines, a new  line  containing two stars or more, and
 ' nothing else, mark the end of the title.

So, a simplified title looks like that: 

<Code (lpm): 
**
* Document Title
*
* This is a test document, with a title
*
**
>

=== The Abstract

We begin the  abstract  with  the  command  <<lpm>\~abstract\~>. We then
write a bunch of paragraphs,  then  close  the abstract with the command
<<lpm>\~\~\~>. 

<Code (lpm): 
~abstract~
This is an abstract of our document.

With **two** paragraphs!
~~~
>

Once  formatted,  the  command  <<lpm>\~Abstract\~>  is  centered,  it's
first letter capitalized. The <<lpm>\~\~\~>  that  close the abstract is
centered  too.  The  paragraphs  of   the   abstract  are  shorter,  and
indented, like here: 

<Code (lpm): 
                               ~Abstract~

    This is an abstract of our document.

    With **two** paragraphs!

                                  ~~~
>

=== The License

The license format is  modeled  after  the  abstract  one, but using the
<<lpm>\~License\~> instead of the <<lpm>\~Abstract\~> one. 

<Code (lpm): 
                               ~License~

    __**LRL Recursive License**__

    //Copyright Tartempion © 1842//

    Permission is granted  to  use,  copy, modify and/or distribute
    this work as long as:

     # You follow the license

    This license is under LRL Recursive license.

                                  ~~~
>

=== The Author(s)

We  can  specify   the   authors   of   the   document   thank   to  the
<<lpm>\~authors> command.  That  command  can  appear  many  times,  and
authors will be grouped and  displayed  under  the title. If the command
appear many times, after formatting,  it  will  again appear many times.
We think that if it as  been  typed  more  than  once, there is a reason
and we should not merge the commands. 

<Code (lpm): 
~authors Ludovic Broutille and Mélanine de Balzac.
>

=== The Project Programming Language

Code blocks will  be  inserted  throughout  the  document.  Those can be
prettified  with  syntax  highlighting,   but   only   if  we  know  the
programming language. We can define  that  language  at each code block,
but to save us from typing it  each  time,  we can also specify the more
used language in  the  document.  We  use  the  command <<lpm>\~code> to
that effect. 

<Code (lpm): 
~code haskell
>

== Formatage des paragraphes

Comme   dit    dans    la    partie    (__Le    format    de    balisage
LPM__)[description du format LPM],  un  paragraphe  est  définit par une
suite de lignes non-vides. Un  paragraphe  commence  à la première ligne
non-vide rencontrée, et s'arrête dès  qu'il  rencontre une ligne vide ou
une  commande.  Les  lignes   succeptibles   de   marquer  la  fin  d'un
paragraphe sont : 
 - les lignes formatées comme une liste,
 - les  lignes  contenant   une   commande   du   type  <<lpm>\~include>
 ' (commençant par un <<lpm>\~>),
 - les lignes marquant le début d'un bloc de code,
 - les lignes marquant une url ou une note de bas de page,
 - les lignes marquant un début de paragraphe important,
 - les lignes marquant un début de section (débutant par <<lpm>\=>),
 - les lignes vides.

=== Formatage du texte

À l'intérieur du paragraphe, il  est  possible d'utiliser des caractères
qui  vont  mettre  le   texte   **en   gras**,   //en  italique//,  __en
souligné__, et même --en barré--. 

Le paragraphe précédent ressemble donc à ceci : 

<Code (lpm): 
À l'intérieur du paragraphe,  il est  possible d'utiliser des caractères
qui vont  mettre  le   texte   **en   gras**,   //en   italique//,  __en
souligné__, et même --en barré--.
>

=== Liens et références

Il est aussi  possible  d'ajouter  des  liens.  Un  lien  est noté entre
crochets, et s'applique au mot  qui  précède,  ou bien au groupe contenu
dans les  parenthèses  qui  précède  (auquel  cas  les  parenthèses sont
supprimées du texte dans le document  généré).  Un lien contenant un mot
est un lien intra-document. Les  liens  vers  l'exterieur sont notés par
deux points, puis rappelés  à  la  fin  du  paragraphe  avec la commande
<<lpm>\..:>. Les liens dont le  mot  commence  par <<lpm>\=> ne sont pas
des liens, mais des  ancres  vers  lesquelles  on  peut  pointer. Ce qui
donne : 

<Code (lpm): 
Un (lien vers l'exterieur)[..], un lien vers une ancre[une ancre].
..:http://example.org/

Du texte.

L'ancre[=une ancre] en question.
>

Comme les liens vers l'exterieur,  il  est  possible  de créer des notes
de bas de page. Pour  cela,  on  place  une  étoile (seule, deux étoiles
correspondant  à  la  mise  en  gras)  à  côté  du  mot  que  l'on  veut
commenter.  La  commande   <<lpm>\*:>   contiendra   le  commentaire  en
question, et  sera  suivit  sur  la  même  ligne  et  les  suivantes  du
paragraphe contenant le commentaire. 

<Code (lpm): 
mon texte avec* une note de bas de page.
*: //avec// est un anagramme de //cave//.
>

    /!\ Pour savoir quelle note  de  bas  de  page ou quelle URL /!\
    /!\ correspond à  une  référence,  le  programme  assigne un /!\
    /!\ nombre à chaque note de  bas  de  page ou chaque URL (il /!\
    /!\ les compte),  ainsi  qu'un  nombre  à  chaque référence. /!\
    /!\ Les références vers  une  URL  vont  pointer  vers l'URL /!\
    /!\ auquel le même nombre  a  été  assigné,  et de même pour /!\
    /!\ les notes de bas de  page.  Si  vous oubliez une note de /!\
    /!\ bas  de  page,  il   y   aura   un   décalage  dans  les /!\
    /!\ références !                                             /!\
    /!\                                                          /!\
    /!\ Il est considéré comme une  bonne  pratique de mettre la /!\
    /!\ note ou l'URL directement  derrière  le paragraphe qui y /!\
    /!\ fait référence,  mais  ce  n'est  pas  obligé.  Une note /!\
    /!\ peut même précéder le  texte  qui  s'y  réfère, tant que /!\
    /!\ le  compte  (l'ordre  des  notes)  n'est  pas  perturbé. /!\
    /!\ Toutefois, ce n'est pas vraiment conseillé.              /!\

=== Les paragraphes importants

Il peut être utile de mettre  en  avant  un paragraphe, comme le dernier
paragraphe de la section précédente.  Pour  celà, on utilise la commande
<<lpm>/!\\>. Cette commande  va  considérer  tout  le  paragraphe qui la
suit comme un  paragraphe  important.  Il  est  possible  de mettre deux
paragraphes dans  un  même  bloc  important  en  plaçant  cette commande
devant les  deux  paragraphes  ainsi  que  sur  la  ligne  vide  qui les
sépare. Enfin, dans la forme complète  de  ces  blocs (car oui, c'est un
bloc de texte qui  est  marqué  comme  important),  chaque ligne du bloc
commence par cette commande, et  termine  aussi  par celle-ci. Comme les
résumés et licences, le bloc sera  un  peu plus court et indenté. Ainsi,
ce code : 

<Code (lpm): 
/!\Un paragraphe
important
/!\
/!\Et un autre paragraphe important

/!\Les deux paragraphes précédents sont dans le même bloc, et celui-ci 
dans un nouveau bloc important.
>

Deviendra : 

<Code (lpm): 
    /!\ Un paragraphe important                                  /!\
    /!\                                                          /!\
    /!\ Et un autre paragraphe important                         /!\

    /!\ Les deux  paragraphes  précédents  sont   dans  le  même /!\
    /!\ bloc, et celui-ci dans un nouveau bloc important.        /!\
>

== Formatage des listes

LPM  permet   de   créer   des   listes   numérotées   et   des   listes
non-numérotées. Les listes numérotées  sont  marquées  par  une suite de
lignes commençant par  <<lpm>\#>,  chaque  <<lpm>\#>  marquant  le début
d'un élément de la liste.  Les  listes  non-numérotées sont marquées par
une ligne  commençant  par  <<lpm>\->,  chaque  <<lpm>\->  marquant,  de
même, le début d'un élément de la liste. 

Si un élément de la liste  tient  sur  plus d'une ligne, il est possible
de continuer sur la ligne  suivante,  sans  débuter de nouvel élément de
liste, en commençant la ligne  par  <<lpm>\'>  plutôt que par <<lpm>\->.
En réalité, une ligne commençant  par  <<lpm>\->  ou <<lpm>\#> et suivie
de lignes commençant par  <<lpm>\'>  devient,  si  on  enlève le premier
caractère  de  ces  lignes,  une  suite  de  blocs  de  textes,  pouvant
contenir d'autres listes, des paragraphes… 

<Code (lpm): 
 - une liste non numérotée
 - un deuxième élément

 # une liste numérotée
 ' le premier élément tenant sur plusieurs lignes
 # Le deuxième élément contient une liste non-numérotée
 ' - Premier élément d'une sous-liste
 ' - Deuxième élément de la sous-liste
 ' ' sur plusieurs lignes
 # Le troisième élément contient deux paragraphes
 '
 ' C'est le deuxième paragraphe du troisième élément.
>

== Commandes d'inclusion de fichiers

Plusieurs commandes  permettent  d'insérer  un  autre  fichier  dans  le
document. Ces commandes prennent en  paramètre  le  chemin  et le nom du
fichier à insérer, relatif  à  la  position  du  fichier  dans lequel la
commande apparaît. 

Prenons  comme  exemple,  pour  illustrer  ce  principe,  l'arborescence
suivante : 
 - document.txt
 - includes 
 ' - canard.txt
 ' - coco.txt

Si le fichier //document.txt//  veut  inclure  //canard.txt//, il faudra
utiliser la commande  <<lpm>\~get  includes/canard.txt>.  Maintenant, si
le fichier //canard.txt//  veut  inclure  //coco.txt//,  il utilisera la
commande <<lpm>\~get coco.txt>,  et  non <<lpm>\~get includes/coco.txt>.
Ce qui compte ici est la  position  du  fichier sur lequel on travaille,
et  non  celle  du  fichier  sur  lequel  aura  été  lancé  la  commande
<<sh>lpm>. 

Il est possible d'insérer une  image  dans  la  documentation grâce à la
commande <<lpm>\~image> : 

<Code (lpm): 
~image img/lolcat.jpg
>

On peut aussi insérer un fichier  texte  brut dans la documentation avec
la commande <<lpm>\~include> : 

<Code (lpm): 
~include rfc/rfc1149.txt
>

Enfin, on peut inclure un  fichier  LPM,  qui  sera  lu et formaté avant
d'être ajouté dans la documentation : 

<Code (lpm): 
~get partie-2.lpm
>

Cette  dernière  commande  est  très  importante,  car  elle  permet  de
fractionner la source de la  documentation  en plusieurs petit fichiers,
facilement éditables dans un  éditeur  de  texte.  Elle permet aussi, en
supposant que l'on a un fichier  par  section,  de créer une « table des
matières » dans le fichier  principal,  et  de  régorganiser le document
juste en modifiant l'ordre de ces inclusions. 

Pour finir, nous désirons  parler  d'une  commande  qui  n'inclue pas, à
proprement parler, de fichier  dans  la  documentation, mais plutôt dans
le code source généré. C'est la commande <<lpm>\~copy>. 

<Code (lpm): 
~copy image.jpg data/image.jpg
>

Cette commande  prend  deux  fichiers  en  paramètres.  Elle  copiera le
fichier passé en  premier,  et  dont  le  positionnement  est  relatif à
celui du fichier en cours  d'édition,  dans  le fichier passé en second,
dont la position sera  relative  au  dossier  dans  lequel sera placé le
code source. Les espaces  et  autres  caractères  pouvant poser problème
doivent être échappés avec <<lpm>\\>. 

== Gestion du code

=== Définition des blocs de code

Une fonctionnalité importante du  langage  LPM  est  la  gestion du code
source. Il est ainsi possible  d'inclure  facilement du code source dans
le document : 

<Code (lpm): 
\<code:
import os
print os.getcwd()
\>
>

Qui va donner : 

<Code: 
import os
print os.getcwd()
>

En  plus  de  cela,  il   est   possible   de  préciser  le  langage  de
programmation utilisé dans le bloc de code, ce qui permet : 
 # de préciser, pour le lecteur,  le  langage  de  ce qu'il est en train
 ' de lire,
 # d'appliquer une coloration syntaxique adaptée au langage.

<Code (lpm): 
\<code (haskell):
fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
fib n = fibs !! n
\>
>

Deviendra : 

<Code (haskell): 
fibs = 0 : 1 : (zipWith (+) fibs (tail fibs))
fib n = fibs !! n
>

Il est possible de nommer un bloc de code : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
void main(){
	printf("Hello, world!\n");
}
\>
>

Et pour finir, à  l'interieur  d'un  bloc  de  code,  il est possible de
faire référence à un bloc de code nommé : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
void main(){
\	<implémentation de main
}
\>
>

=== Programmation lettrée, la toile de code

Cette dernière fonctionnalité nous ammène  à  aborder  le principe de la
programmation lettrée : nous écrivons de  petits  morceaux de code, dans
lesquels nous incluons des  références  vers  d'autres morceaux de code.
Il est aussi possible de  commencer  un  bloc  de code, puis de rajouter
plus tard du code  dans  celui-ci  en  créant  un  nouveau  bloc de code
portant le même nom.  Cette  manière  de  présenter  le  code, emmêlé et
avec des références, fait  penser  au  Web  et  ses liens hypertexte, et
bien que la programmation lettrée  aie  été  inventée bien avant le Web,
sont auteur avait déjà saisi le  concept  de toile d'idées créée par les
références et nommé son invention Web : la toile. 

Ainsi, avec la collection de blocs de code suivante : 

<Code (lpm): 
\<code (c): test.c
#include <stdio.c>
\>
>

<Code (lpm): 
\<code (c): test.c
void main(){
\	<implémentation de main
}
\>
>

<Code (lpm): 
\<code (c): implémentation de main
printf("Hello, world!");
\>
>

Le morceau de code  //test.c//  sera  réunifié,  puis  la référence vers
//implémentation de main// sera résolue  et  remplacée par le morceau de
code portant ce nom.  Toutes  les  lignes  du  code  ainsi inséré seront
indentées  d'autant  de  caractères  que  ce  qui  précède  la  commande
référençant  le  bloc.   Cette   fonctionnalité   est   nécessaire  pour
permettre d'obtenir  un  code  source  lisible  d'une  part,  et d'autre
part, pour supporter  certains  langages  dans  lesquels l'indentation a
un sens  (il  serait  impossible  d'écrire  du  python  en programmation
lettrée sans ça). 

Afin de générer le code source,  le  programme  va regarder les blocs de
code nommés. Pour ceux  qui  n'ont  jamais  été référencés, le programme
considère qu'ils doivent être sortis  dans  un  fichier texte portant le
nom du bloc de code. 

Dans l'exemple précédent, //test.c//  n'est  jamais  inclu dans un autre
bloc  de  code,  et  un   fichier   sera   donc  créé  portant  ce  nom.
//implémentation de main//, par contre,  est  inséré  dans un autre bloc
de code, et il ne sera donc pas extrait dans un fichier.* 
 *: En l'occurence, il le  sera,  mais  seulement  parce  que le morceau
    dans lequel il est inclu, //test.c//,  est  lui même extrait dans un
    fichier.

=== Morceaux de code dans les paragraphes

Il est possible d'indiquer qu'une  portion  de  texte à l'interieur d'un
paragraphe  est  du  code.   Ceci   permet   d'appliquer  la  coloration
syntaxique à ces morceaux  de  code.  Nous  marquons  un passage de code
dans un  texte  en  l'entourant  des  signes  inférieur  et  supérieur :
<<lpm>\<import os\>>. Il est  possible  de  spécifier  le  langage de ce
morceau de code en ajoutant,  directement  après  le signe inférieur, le
langage     entouré      lui      aussi      des      même      signes :
<<lpm>\<\<C\>printf("Wouhou!")\>>. 

=== Récapitulatif de code

Il peut être utile, après avoir  décrit  un  bloc de code petit à petit,
de présenter un  récapitulatif  de  ce  code.  Deux commandes permettent
d'afficher le code qui a été généré : 

La première commande permet de  rappeler  le  contenu d'un bloc de code,
et affiche tout le code de  ce  bloc,  même si celui-ci était morcelé en
plusieurs blocs portant le même nom : 

<Code (lpm): 
~remain morceau de code
>

La seconde  commande  permet  non  seulement  d'afficher  un  morceau de
code, mais  surtout  d'afficher  celui-ci  sans  aucune  référence  vers
d'autres morceaux de code,  c'est  à  dire  qu'il  les remplace par leur
contenu. Ainsi, utiliser  cette  commande  sur  un  bloc  destiné à être
sortit dans un fichier revient  à  insérer  dans  le document le contenu
de ce fichier.  Mais  il  est  possible,  bien  sûr,  d'insérer juste un
morceau de code,  la  commande  fonctionnant  sur  ceux-ci,  et  non pas
exclusivement sur les blocs destinés à être sortis dans un fichier. 

Cette commande est celle-ci : 

<Code (lpm): 
~display morceau de code
>

== Échappement de caractères

=== Échappement de caractères dans les paragraphes

Lorsque nous utilisons  des  caractères  qui  devraient être interprétés
par LPM, mais que nous  les  voulons  tels  quels,  il est nécessaire de
les échapper. Ceci se  fait  à  la  mode  Unix :  tout caractère précédé
d'un <<lpm>\\> sera rendu tel  quel,  sans être interprété. Par exemple,
<<lpm>\\\*\*> affichera <<lpm>\*\*>.  Pour  un  exemple  plus compliqué,
considéront    l'affichage    du    morceau     de    code    suivant* :
<<lpm>\<\<C\>printf("Wouhou!")\>>. Pour arriver à  ce  résultat, il aura
fallut échapper  les  caractères  spéciaux  dans  le  morceau  de  code,
notamment le <<lpm>\>> qui aurait  fermé  le  bloc sinon. Le code source
de       ce       morceau       de       code       est       celui-ci :
<<lpm>\<\<lpm\>\\\<\\\<C\\\>printf("Wouhou!")\\\>\>>. 
 *: Ceci est un morceau de code LPM, pas un morceau de code C.

=== Échappement de caractères dans les blocs de code

Si une ligne  de  code  commence  par  <<lpm>\<>,  elle sera interprétée
comme une référence vers un  autre  bloc  de  code. Si elle commence par
<<lpm>\>>, elle sera  interprétée  comme  une  sortie  du  bloc de code.
Pour empêcher cela, on peut  échapper  la  ligne,  en la débutant par le
caractère <<lpm>\\>.  Contrairement  à  l'échappement  traditionnel,  ce
caractère, dans les blocs de  code,  va  échapper  la ligne entière, qui
peut ensuite contenir n'importe quoi, et non pas juste un caractère. 

Ainsi : 

<Code (lpm): 
\<code:
import os
\\<coco
\>
>

Va donner : 

<Code (lpm): 
import os
\<coco
>

Et pour afficher  ce  bloc  de  code,  il  a  fallut  échapper  la ligne
commençant  par  <<lpm>\\>,  //non   pas   en   échappant  le  caractère
<<lpm>\\>,  mais  bien  la  ligne   entière//.  Le  code  utilisé  était
celui-ci : 

<Code (lpm): 
\<code (lpm):
\\<code:
import os
\\\<coco
\\>
\>
>

//On voit bien ici que  l'on  n'a  échappé  que  le <<lpm>\\>, et pas le
<<lpm>\\\<>, qui aurait  dû  être  échappé  <<lpm>\\\\\\\<>  (au lieu de
<<lpm>\\\\\<>) si nous échappions caractère  par  caractère et non ligne
par ligne.// 

