LPM
===

What?
-----

LPM is a literate programming tool. First, it is a markup language (LPM stands
for Literate Programming Markup), and second, a tool that can parse this
markup. With LPM, you can write a “book”, which describe the implementation of
a software, and extract from it the source code of said software, and generate
a nice looking documentation (for now, in HTML only). Additionally, and unlike
most other literate programming tools, LPM is thought to enable you not only to
generate a nice documentation file, but also a nice documentation **source
code**. 

LPM was designed for a french team. Some of the documentation is not yet
translated in english. That's the part of the documentation that may never be
translated: my requirement for the tool have slightly changed, and I may wipe
out entirely the implementation text already written (As I will switch from
Python to C, I think, that will change the program architecture. Also, I
hopefully progressed in programmation, and will have a new look at my code
design. For all these reason, the remaining french text may disappear instead
of being translated.). Don't panic, to begin with, that implementation part
**never** had been in a working state.

What? Well, we have a “bootstrap script”, `_lpm`. It is a prototype, written in
less than a day (if I remember correctly), and not easily hackable. The `lpm`
file and those in the `doc` directory are a reimplementation in literate
programming. So, LPM exists, it works, it's that `_lpm` prototype. Only the
clean and full featured implementation is not working.

Why?
----

One thing that I did not find really nice when doing literate programming with
traditionnal tools was that the source code was not easily readable. Yes, we
could read a beautiful documentation generated by LaTeX, but... Well, when
writing the code, it was ugly. Ok, that's just my opinion, but I don't like how
LaTeX source code looks like. I really prefer things like Markdown or
reStructuredText. But those are not aimed at literate programming, and it was
not obvious to me how to use them to fulfill my goal. So, I wrote my own
lightweight markup language, aimed at writting documentation (like
reStructuredText), with an easy way to insert code (indenting all of our code
like in Markdown or reStructuredText is not really easy), and to reorganize it.

How?
----

Well, it has it's own markup language. With some documentation elements, like
abstract, license placeholder, title, sections, subsections...

Code is delimited by special syntax, and can be named. We also are able to
specify the language of the code, for nice syntax highlighting. The
documentation can be splitted in different files. We can insert our blocks of
code in the documentation to refresh the mind of the reader. 

And because the goal was to have a literate source as pretty as the literate
documentation generated, there is a refactoring tool that format the source,
justifying text, cleaning paragraphs blocks, and all that stuff. Take a look to
the files, and you will see that their structure is nice to the eyes. And
that's the source code, not the final document!

Of course, that tool does not only generate documentation. It is able to
extract the source code, too. It would be useless without that.

Your code is ugly.
------------------

You're talking about the prototype, right? Yep. That was a prototype, quickly
hacked. And it's buggy, too. But it works well enough to begin with, and we'll
write a better version of it, using it. I needed to bootstrap my literate
programming language.

Also, I just translated the documentation from french to english. There can be
too “literal” translations. I'll read my text again and hopefully catch some
frenchy stuff. But I'm not native english speaker, I will need to be corrected
on some points _please_.

How to use that prototype?
--------------------------

The prototype understand three commands: Weave, Tangle, Format. If you run
`_lpm literate_program`, it will extract the source and documentation of
`literate_program`, and generate a file called `literate_program.clean`, which
should contain the same text as `literate_program`, but well formatted (be
careful, there can be data loss, that's why we don't overwrite the original
file by default).

If you only want to weave, tangle or format your program, for efficiency
reasons, you can create a link to `_lpm`, with it's filename set to the
action you want. So, `format literate_program` will only generate the
“.clean” file, without extracting the source and the documentation. Unlike said
in the documentation, the prototype only understand file strictly named after
one action. The versatility described in the documentation is the one of the
final product!

